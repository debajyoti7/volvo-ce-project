<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!-- #BeginTemplate "/Templates/documentation.dwt" --><!-- #BeginEditable "doctitle" --><!-- #EndEditable -->
    <meta http-equiv="Content-Type" content="text/html;
      charset=ISO-8859-1">
    <title>Amos II Release 14 User's Manual</title>
  </head>
  <body bgcolor="#ffffff">
    <table name="page_contents" border="0" cellpadding="5"
      cellspacing="5">
      <tbody>
        <tr>
          <td align="left" valign="top" width="235">
            <table style="width: 317px; height: 1166px;" border="0"
              cellpadding="2" cellspacing="2">
              <tbody>
                <tr>
                  <td style="vertical-align: top;"><br>
                  </td>
                  <td> <a
                      href="http://www.it.uu.se/research/group/udbl/amos"><img
src="http://www.it.uu.se/research/group/udbl/img/amos_logo_53x50.jpg"
                        height="50" width="53"> </a> </td>
                </tr>
                <tr>
                  <td style="vertical-align: top;"><br>
                  </td>
                  <td><!-- #BeginEditable "submenu" -->
                    <ol>
                      <li><font face="Arial, Helvetica, sans-serif"><font
                            size="-1"><a href="#running">Getting started<br>
                            </a></font></font></li>
                      <li><font face="Arial, Helvetica, sans-serif"><font
                            size="-1"><a href="#syntax">AmosQL</a></font></font>
                        <br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.1 <a href="#types">Types</a></font></font>
                        <br>
                        2.1.1 <a href="#delete-type">Deleting types</a><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.2 <a href="#create-object">Objects</a></font></font>
                        <br>
                        2.2.1 <a href="#object-deletion">Deleting
                          objects</a><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.3 <a
                              href="amos_users_guide.html#query-statement">Queries</a></font></font>
                        <br>
                        2.3.1 <a
                          href="amos_users_guide.html#function-call">Function




                          calls</a><br>
                        2.3.2 <a
                          href="amos_users_guide.html#select-statement">The




                          select statement</a><br>
                        2.3.3 <a
                          href="amos_users_guide.html#predicate-expressions">Predicate




                          expressions<br>
                        </a>2.3.4 <a href="#quantifiers">Quantifiers</a><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.4 <a
                              href="#function-definitions">Functions</a></font></font>
                        <br>
                        2.4.1 <a href="#deletef">Deleting functions</a><br>
                        2.4.2 <a href="#overloaded-functions">Overloaded




                          functions</a><br>
                        2.4.3 <a href="#casting">Casting</a><br>
                        2.4.4 <a href="#second-order-functions">Second
                          order functions</a><br>
                        2.4.5 <a href="#transitive-closures">Transitive
                          closures</a><br>
                        2.4.6 <a href="#abstract-functions">Abstract
                          functions</a><br>
                        2.5 <a href="#updates">Updates</a><br>
                        2.5.1 <a href="#2.5.1_Cardinality_constraints">Cardinality




                          constraints</a><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.5.2<span style="text-decoration:
                              underline;"> </span><a href="#add-type">Dynamically




                              changing object types</a><br>
                            2.5.3 <a href="#user-update-functions">User
                              update procedures</a><br>
                            2.5.4 <a href="#dynamic-updates">Dynamic
                              updates</a><br>
                            2.6 <a href="#collections">Collections</a><br>
                            2.6.1 <a href="#subqueries">Aggregate
                              functions and subqueries</a><br>
                            2.6.2 </font></font> <font face="Arial,
                          Helvetica, sans-serif"><font size="-1"><a
                              href="amos_users_guide.html#bag-semantics">Bags</a></font>
                        </font><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.6.3 <a href="#vectors">Vectors</a><br>
                            2.6.4 <a href="#records">Key-value
                              associations</a><br>
                            <font face="Arial, Helvetica, sans-serif"><font
                                size="-1">2.7 <a href="#data-mining">Data




                                  mining primitives<br>
                                </a>2.7.1 <a href="#top-k">Top-k
                                  queries</a><br>
                              </font></font></font></font><font
                          face="Arial, Helvetica, sans-serif"><font
                            size="-1">2.7.2 <a
                              href="amos_users_guide.html#group-by">Grouped




                              aggregation</a></font></font><br>
                        <font face="Arial, Helvetica, sans-serif"><font
                            size="-1"><font face="Arial, Helvetica,
                              sans-serif"><font size="-1">2.7.3 <a
                                  href="#vector-numerical">Numerical
                                  vector functions</a><br>
                                2.7.4 <a href="#vector-aggregate">Vector




                                  aggregate functions</a><br>
                                2.7.5 <a href="#plot">Plotting
                                  numerical data<br>
                                </a>2.8 <a
                                  href="#2.8_Accessing_data_in_files">Accessing




                                  data in files</a><br>
                                2.9 <a href="#cursors">Cursors</a></font></font></font></font></li>
                      <font face="Arial, Helvetica, sans-serif"><font
                          size="-1">
                          <li><font face="Arial, Helvetica, sans-serif"><font
                                size="-1"><a href="#procedures">Procedural




                                  functions</a></font></font> <br>
                            <font face="Arial, Helvetica, sans-serif"><font
                                size="-1">3.1 <a
                                  href="#foreach-statement">Iterating
                                  over results</a></font></font> <br>
                          </li>
                          <li><a href="#SQL-processor">The SQL processor</a><br>
                          </li>
                          <li><a href="#peers">Peer management</a><br>
                            <font face="Arial, Helvetica, sans-serif"><font
                                size="-1"><a href="#peers">5.1 Peer
                                  communication</a></font></font> <br>
                            <font face="Arial, Helvetica, sans-serif"><font
                                size="-1"><a href="#peer-views">5.2 Peer
                                  queries and views</a></font></font> <br>
                          </li>
                          <li><font face="Arial, Helvetica, sans-serif"><font
                                size="-1"><a href="#mediatorfns">Accessing




                                  external systems</a></font></font>&nbsp;





                            <font face="Arial, Helvetica, sans-serif"><font
                                size="-1"><br>
                                6.1 <a href="#foreign-functions">Foreign




                                  and Multi-directional functions</a><br>
                                6.1.1 <a href="#cost-estimate">Cost
                                  estimates</a><br>
                                <font face="Arial, Helvetica,
                                  sans-serif"><font size="-1">6.2 <a
                                      href="#relational">The relational
                                      database wrapper<br>
                                    </a></font></font></font></font>6.2.1




                            <a href="#rdb-connect">Connecting</a><br>
                            6.2.2 <a href="#rdb-metadata">Accessing
                              meta-data</a><br>
                            6.2.3 <a href="#rdb-SQL">Executing SQL</a><br>
                            6.2.4 <a href="#rdb-ooview">Object-oriented
                              view of tables</a><font face="Arial,
                              Helvetica, sans-serif"><font size="-1"><font
                                  face="Arial, Helvetica, sans-serif"><font
                                    size="-1"><font face="Arial,
                                      Helvetica, sans-serif"><font
                                        size="-1"><br>
                                        6.3 <a
                                          href="amos_users_guide.html#generic_wrapper">Defining




                                          new wrappers<br>
                                        </a></font></font><font
                                      face="Arial, Helvetica,
                                      sans-serif"><font size="-1">6.3.1
                                        <a
                                          href="amos_users_guide.html#data-sources">Data




                                          sources</a><br>
                                        6.3.2 <a
                                          href="amos_users_guide.html#mapped">Mapped




                                          types</a><br>
                                        6.3.3 <a
                                          href="amos_users_guide.html#type-translation">Type




                                          translation</a><br>
                                      </font></font></font></font></font></font>
                          </li>
                          <font face="Arial, Helvetica, sans-serif"><font
                              size="-1">
                              <li><font face="Arial, Helvetica,
                                  sans-serif"><font size="-1"><a
                                      href="#physical">Physical database
                                      design</a></font></font><br>
                              </li>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">7.1 <a href="#indexing">Indexing</a></font></font>
                              <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">7.2 <a href="#62005">Clustering</a></font></font>
                              <li><font face="Arial, Helvetica,
                                  sans-serif"><font size="-1"><a
                                      href="#62031">System functions and
                                      commands</a></font></font><br>
                              </li>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.1 <a href="#62035">Comparison




                                    operators</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.2 <a href="#62053">Arithmetic




                                    functions</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.3 <a href="#STRING">String




                                    functions</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.4 <a href="#62087">Aggregate




                                    functions</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.5 <a href="#TEMPORAL">Temporal




                                    functions</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.6 <a href="#SORT">Sorting
                                    functions</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.7 <a
                                    href="#system-metadata">Accessing
                                    system meta-data</a></font></font> <br>
                              8.7.1 <a href="#type-metadata">Type
                                meta-data</a><br>
                              8.7.2 <a href="#function-metadata">Function




                                meta-data</a><br>
                              8.8 <a href="#code-search">Searching
                                source code</a><br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.9 <a href="#extents">Extents</a></font></font>
                              <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.10 <a href="#62191">Query
                                    optimizer tuning</a></font></font> <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.11 <a href="#unloading">Unloading</a></font></font>
                              <br>
                              <font face="Arial, Helvetica, sans-serif"><font
                                  size="-1">8.12 <a href="#62283">Miscellaneous</a></font></font><br>
                              <li><font face="Arial, Helvetica,
                                  sans-serif"><font size="-1"><a
                                      href="#62618">References</a>&nbsp;</font></font></li>
                            </font></font> </font></font>
                    </ol>
                    <!-- #EndEditable --></td>
                </tr>
              </tbody>
            </table>
          </td>
          <td align="left" valign="top">
            <table style="width: 486px; height: 1039px;" border="0"
              cellpadding="0" cellspacing="0">
              <tbody>
                <tr>
                  <td>
                    <table border="0" cellpadding="0" cellspacing="0"
                      width="250">
                      <tbody>
                        <tr valign="middle">
                        </tr>
                      </tbody>
                    </table>
                  </td>
                </tr>
                <tr>
                  <td height="10">&nbsp;</td>
                </tr>
                <tr>
                  <td><!-- #BeginEditable "contents" -->
                    <h1>Amos II Release 14 User's Manual</h1>
                    <i>Staffan Flodin, Martin Hansson, Vanja Josifovski,
                      Timour Katchaounov, Tore Risch, Martin Sk&ouml;ld,
                      and Erik Zeitler </i>
                    <p> <a
                        href="http://www.it.uu.se/research/group/udbl">Uppsala




                        DataBase Laboratory</a><br>
                      Department of Information Technology<br>
                      Uppsala University<br>
                      Sweden </p>
                    <p>January 9,&nbsp; 2012<br>
                    </p>
                    <h1>Summary</h1>
                    <p>Amos II is an extensible mediator database system
                      allowing different kinds of distributed data
                      sources to be queried. The system is centered
                      around an object-relational and functional query
                      language, AmosQL, documented here. The system can
                      store data in its main-memory object store.
                      Furthermore, <span style="font-style: italic;">wrappers



                      </span>can be defined for different kinds of data
                      sources and external storage managers accessed to
                      make them queryable. This manual describes how to
                      use the Amos II system and the AmosQL query
                      language. Several distributed Amos II <span
                        style="font-style: italic;">peers</span> can
                      collaborate in a federation. The documentation
                      includes documentation of basic peer communication
                      primitives, multi-database queries and views, the
                      wrapper functionality, and the predefined wrappers
                      for relational databases through&nbsp; JDBC.&nbsp;
                      The principles of the Amos II system and AmosQL
                      are described in the document <a
                        href="file:///C:/AmosNT/doc/amos_users_guide.html#RJK03">[RJK03]</a>.
                      Amos II now also includes primitives for data
                      mining through functions for data analyzis,
                      aggregation,&nbsp; visualization, and handling of
                      ordered collections through the datatype <span
                        style="font-style: italic;">Vector</span>.<br>
                    </p>
                    The basic wrapper interface is based on user defined
                    <span style="font-style: italic;">multi-directional</span>
                    foreign functions having various <span
                      style="font-style: italic;">capabilities</span>
                    used to access external data sources in different
                    ways <a href="#LR92">[LR92]</a> depending on what
                    variables are bound or free in an execution plan,
                    the <span style="font-style: italic;">binding
                      patterns</span>. On top of the basic foreign
                    function mechanism object oriented abstractions are
                    defined through <span style="font-style: italic;">mapped




                      types</span> <a href="#FR97">[FR97]</a>. A number
                    of important query rewrite techniques for scalable
                    access to wrapped sources, in particular relational
                    databases, are described in <a
                      href="file:///C:/AmosNT/doc/amos_users_guide.html#FR97">[FR97]</a>.
                    Rewrites for handling scalable execution of queries
                    involving late bound function calls are described in
                    <a href="#FR95">[FR95]</a>. Multi-database views are
                    further described in&nbsp;<a
                      href="file:///C:/AmosNT/doc/amos_users_guide.html#JR99a">[JR99a]</a><a
href="file:///C:/AmosNT/doc/amos_users_guide.html#JR99b">[JR99b]</a>.
                    The distributed query decomposer is described in <a
                      href="#JR02">[JR02]</a> and <a href="#KJR03">[KJR03]</a>.
                    <br>
                    <h1>Acknowledgments</h1>
                    The following persons have contributed to the
                    development of the Amos II Release 14 system: <br>
                    Sobhan Badiozamany, Kristofer Cassel, Daniel Elin,
                    Gustav Fahl, Staffan Flodin, Ruslan Fomkin,
                    J&ouml;rn Gebhardt, Gyozo Gidofalvi, Martin Hansson,
                    Milena Ivanova, Vanja Josifovski, Markus
                    J&auml;gerskogh, Jonas Karlsson, Timour
                    Katchaounov,&nbsp; Salah-Eddine Machani, Lars
                    Melander, Joakim N&auml;s, Kjell Orsborn, Thomas
                    Padron-McCarthy, Johan Petrini, Tore Risch,
                    Manivasakan Sabesan, Martin Sk&ouml;ld, Silvia
                    Stefanova, Thanh Truong, Christian Werner, Magnus
                    Werner, and Erik Zeitler.<!--


















#EndEditable --> </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
        <tr>
        </tr>
      </tbody>
    </table>
    <!-- #BeginEditable"main_contents" -->
    <p><a name="running"></a> </p>
    <h1>1 Getting started<br>
    </h1>
    Download the Amos II zip file from <a
      href="http://www.it.uu.se/research/group/udbl/amos/">http://www.it.uu.se/research/group/udbl/amos/</a>.
    Unpack the zip file to a directory for Amos II, <tt>&lt;privdir&gt;</tt>.
    The following files are needed in <tt>&lt;privdir&gt;</tt>:
    <pre> 
amos2.exe
amos2.dll
amos2.dmp
</pre>
    Amos II is ready to run in <tt>&lt;privdir&gt;</tt> by the
    command:&nbsp;
    <pre>amos2 [&lt;db&gt;]</pre>
    where<tt> [&lt;db&gt;]</tt> is an optional name of an Amos II
    database image.&nbsp; <br>
    You need not connect to any particular database, but instead, if<tt>
      &lt;db&gt;</tt> is omitted, the system enters an empty database (<tt>amos2.dmp</tt>),


    where only the system objects are defined. The system looks for <span
      style="font-family: monospace;">amos2.dmp</span> in the same
    directory as where the executable <span style="font-family:
      monospace;">amos2.exe</span> is located.<br>
    <br>
    The executable has a number of command line parameters to specify,
    e.g., the database or AmosQL script to load. To get a list of the
    command line parameters do:<br>
    <span style="font-family: monospace;">&nbsp; amos2 -h</span><br>
    <br>
    <br>
    <big style="text-decoration: underline;">The Amos II toploop</big><br>
    <br>
    When started, the system enters an Amos II top loop where it reads
    AmosQL statements, executes them, and prints their results.&nbsp;
    The prompter in the Amos II top loop is:&nbsp;
    <pre>Amos n&gt;</pre>
    where <tt>n</tt> is a <i>generation number</i>. The generation
    number is increased every time an AmosQL database update statement
    is executed in the Amos II top loop. <br>
    Typically you start by defining&nbsp; meta-data (a schema) as <a
      href="#types">types</a> and <a href="#function-definitions">functions</a>.
    For example:&nbsp;
    <pre>Amos 1&gt; create type Person;<br>Amos 2&gt; create function name(Person)-&gt;Charstring as stored;<br>Amos 3&gt; create function father(Person)-&gt;Person as stored;<br>Amos 4&gt; create type Student under Person;<br></pre>
    Often you load AmosQL definitions from a script rather than entering
    them on the command line, e.g.<br>
    <span style="font-family: monospace;">Amos 1&gt; &lt;
      'mycode.amosql';</span><br>
    <br>
    When the meta-data is defined you usually populate the database with
    by <a href="#create-object">creating objects</a> and <a
      href="#updates">updating functions</a>. For example:<br>
    <span style="font-family: monospace;">Amos 5&gt; create Person(name)
      instances ("Jacob"),("Sam");<br>
      Amos 6&gt; </span><span style="font-family: monospace;">set
      father(p) = q <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      from Person p, Person q <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where name(p)="Jacob" and name(q) = "Sam";</span><br>
    <br>
    <a href="#interface-vardecl">Interface variables</a> can be used to
    bind created object.&nbsp; For example:<br>
    <span style="font-family: monospace;">Amos 7&gt; create Person(name,
      father) instances :b ("Bill",nil), ("John",:b);<br>
    </span><br>
    Notice that interface variables&nbsp; are <span style="font-style:
      italic;">not</span> part of the database but simply place holders
    for created objects when running AmosQL scripts.<br>
    <br>
    When the database is populated you can <a href="#query-statement">query</a>
    it, e.g.<br>
    <span style="font-family: monospace;">Amos 8&gt; select
      name(father(p)) from Person p;<br>
      <br>
    </span><br>
    <big style="text-decoration: underline;">Transactions</big><br>
    <br>
    <a name="rollback"></a>Database changes can be undone by using the <tt>rollback</tt>
    statement with a generation number as argument. For example, the
    statement:&nbsp;
    <pre>Amos 4&gt; rollback 2;</pre>
    will restore the database to the state it had at generation number
    2. In the example it thus undoes the effect of the statements
    after:&nbsp;
    <pre>create type Student under Person;</pre>
    After the rollback above, the type <tt>Student</tt> is removed from
    the database, but not type <tt>Person</tt>. <br>
    A rollback without arguments undoes all database changes of the
    current transaction. All interface variables are cleared by
    rollback.<br>
    <br>
    <p><a name="commit"></a>The statement <tt>commit</tt> makes changes
      non-undoable, i.e. all updates so far cannot be rolled back any
      more and the generation numbering starts over from 1.&nbsp; </p>
    <p>For example:&nbsp; </p>
    <pre>Amos 2&gt; commit;<br>Amos 1&gt; ...<br></pre>
    All interface variables are cleared by rollback.
    <p><big style="text-decoration: underline;">Saving and quitting</big><br>
    </p>
    <p>When your Amos II database is defined and populated, it can be
      saved on disk with the AmosQL statement:&nbsp; </p>
    <pre>save "filename";</pre>
    <p>In a later session you can connect to the saved database by
      starting Amos II with:&nbsp; </p>
    <pre>amos2 filename</pre>
    <br>
    To shut down Amos II orderly first save the database and then
    type:&nbsp;
    <pre>Amos 1&gt; quit;</pre>
    <p> <span style="font-weight: bold;">This is all you need to get
        started with Amos II.</span> </p>
    The remaining chapters in this document describe the basic Amos II
    commands. As an example of how to define and populate an Amos II
    database, cunt-and-paste the commands in <a
      href="http://www.it.uu.se/research/group/udbl/amos/doc/example.osql">http://www.it.uu.se/research/group/udbl/amos/doc/example.osql</a>.
    There is an Amos II tutorial in <a
      href="http://www.it.uu.se/research/group/udbl/amos/doc/tut.pdf">http://www.it.uu.se/research/group/udbl/amos/doc/tut.pdf</a>.<br>
    <br>
    <p><big style="text-decoration: underline;">Java interface</big><br>
    </p>
    <p><i>JavaAmos</i> is a version of the Amos II kernel connected to
      the Java virtual machine. With JavaAmos Java programs can call
      Amos II functions and send AmosQL statements to Amos II for
      evaluation (the <i>callin</i> interface) <a
        href="amos_users_guide.html#ER00">[ER00]</a>. You can also
      define Amos II <a href="amos_users_guide.html#foreign-functions">foreign



        functions</a> in Java (the <i>callout</i> interface). To start
      JavaAmos use the script </p>
    <pre>  javaamos<br></pre>
    instead of <tt>amos2</tt>. It will enter a top loop reading and
    evaluating AmosQL statements as <tt>amos2</tt>. JavaAmos requires
    the Java jar file <span style="font-family: monospace;">javaamos.jar</span>.<br>
    <br>
    <br>
    <big style="text-decoration: underline;">Back-end relational
      databases</big><br>
    <br>
    Amos II release 14 includes a wrapper of relational databases using
    JDBC on top of JavaAmos. Any relational database can be accessed in
    terms of AmosQL using this wrapper. The interface is described in
    the section <a href="#relational">Relational database wrapper</a>.<br>
    <br>
    <p style="text-decoration: underline;"><big>Graphical database
        browser</big></p>
    <p>The multi-database browser GOOVI <a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#CR01">[CR01]</a>
      is a graphical browser for Amos II written as a Java application.
      You can start the GOOVI browser from the JavaAmos top loop by
      calling the Amos II function </p>
    <pre>goovi();</pre>
    It will start the browser in a separate thread. <br>
    <br>
    <br>
    <big style="text-decoration: underline;">PHP interface</big><br>
    <br>
    Amos II release 14 includes an interface allowing programs in PHP to
    call Amos II servers. The interface is tested for Apache servers. To
    use Amos II with PHP or SQL under Windows you are recommended to
    download and install WAMP <a href="http://www.wamp.org/">http://www.wamp.org/</a>).




    WAMP packages together a version of the Apache web server, the&nbsp;
    PHP script language, and the MySQL database. Amos II&nbsp; is tested
    with WAMP 2.0. See further the file <span style="font-style:
      italic;">readme.txt</span> in subdirectory <span
      style="font-style: italic;">embeddings/PHP</span> of the Amos II
    download.<br>
    <br>
    <br>
    <big style="text-decoration: underline;">C interface</big><br>
    <br>
    The system is interfaced with the programming language C (and C++).
    As with Java, Amos&nbsp; II can&nbsp; be called from C (callin
    interface) and foreign Amos II functions can be implemented in C.
    See <a href="#Ris00a">[Ris00a]</a>.<br>
    <br>
    <br>
    <big style="text-decoration: underline;">Lisp interface</big><br>
    <br>
    There is a built-in interpreter for the programming language
    CommonLisp in Amos II, <span style="font-style: italic;">aLisp</span>
    <a href="#Ris00b">[Ris00b]</a>. The system can be accessed and
    extended using <span style="font-style: italic;">aLisp</span>. See
    <a href="#Ris00a">[Ris00a]</a>.<br>
    <a name="syntax"></a>
    <h1> 2 AmosQL<br>
    </h1>
    This section describes the syntax of AmosQL and explains some
    semantic details. For the syntax we use BNF notation with the
    following special constructs:&nbsp;
    <p>A ::= B C: A consists of B followed by C.&nbsp; <br>
      A ::= B | C, alternatively (B | C): A consists of B or C.<br>
      A ::= [B]: A consists of B or nothing.<br>
      A ::= B-list: A consists of one or more Bs.<br>
      A ::= B-commalist: A consists of one or more Bs separated by
      commas.<br>
      'xxx': The string (keyword) xxx.</p>
    <p>AmosQL statements are always terminated by a semicolon (;).<br>
      <br>
    </p>
    <h3><a name="comments"></a> Comments</h3>
    The comment statement can be placed anywhere outside identifiers and
    constants.&nbsp; <br>
    Syntax:
    <pre>comment ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/*' character-list '*/'</pre>
    <h3><br>
    </h3>
    <h3><a name="Identifiers"></a> Identifiers</h3>
    Identifiers have the syntax:
    <pre>identifier ::=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ('_' | letter) [identifier-character-list]&nbsp;<br>
identifier-character ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alphanumeric | '_'<br><br>E.g.: MySalary<br>     &nbsp;x<br>     &nbsp;x1234<br>     &nbsp;x1234_b<br></pre>
    <span style="font-weight: bold;">Notice</span> that Amos II
    identifiers are NOT case sensitive; i.e. they are always internally
    capitalized. By contrast Amos II keywords are always written with
    lower case letters. &nbsp;
    <h3><br>
    </h3>
    <h3><a name="variables"></a> Variables</h3>
    Variables are of two kinds: <i>local variables</i> or <i>interface
      variables</i>:<br>
    <br>
    <tt>&nbsp; &nbsp;variable ::= local variable | interface-variable</tt><br>
    <br>
    <ul>
      <li> <i>Local variables</i> are identifiers for data values
        inside AmosQL queries and functions. <i>Local variables</i>
        must be declared in function signatures (<a
          href="#function-definitions">Function definitions</a>), in
        from clauses (<a href="#query-statement">Queries</a>), or by the
        <tt>declare</tt> statement (see <a href="#procedures">procedural




          functions</a>). Notice that variables are <b>not</b> case
        sensitive.</li>
      <p> Syntax:<br>
        <tt>local-variable ::= <a href="#Identifiers">identifier</a><br>
        </tt></p>
      <p><tt>&nbsp; &nbsp;E.g. my_variable<br>
          &nbsp; &nbsp; &nbsp; &nbsp; MyVariable2<br>
        </tt> </p>
      <p> </p>
      <li> <tt><a name="interface-vardecl"></a></tt><i>Interface
          variables</i> hold only <b>temporary</b> results during
        interactive sessions. Interface variables <b>cannot </b>be
        referenced in function bodies and they are <b>not </b>stored
        in the database. Their lifespan is the current transactions
        only. Their purpose is to hold temporary values in scripts and
        database interactions.<br>
      </li>
      <p> Syntax:<br>
        <tt>interface-variable ::= ':' <a href="#Identifiers">identifier</a></tt></p>
      <p><tt>&nbsp; &nbsp;E.g. :my_interface_variable<br>
          &nbsp; &nbsp; &nbsp; &nbsp; :MyInterfaceVariable2<br>
        </tt></p>
      <p>Interface variables are by default untyped (of type <span
          style="font-style: italic;">Object</span>). The user can
        declare an interface variable to be of a particular type by the
        <span style="font-style: italic;">interface variable declare
          statement</span>:<br>
      </p>
      <p><tt>interface-variable-declare-stmt ::= 'declare'
          interface-variable-declaration-commalist<br>
        </tt></p>
      <p><tt>interface-variable-declaration ::= <a href="#types">type-spec</a>
          interface-variable<br>
        </tt><tt><br>
          &nbsp;&nbsp; E.g. declare Integer :i, Real :x3;</tt><br>
      </p>
      <p>Interface variables can be assigned either by the into-clause
        of the select statement or by the interface variable assignment
        statement <span style="font-family: monospace;">set</span>:<br>
        <tt><br>
          <a name="set-statement"></a>set-interface-variable-stmt ::=
          'set' interface-variable '=' <a href="#expressions">expr</a><br>
        </tt></p>
      <p><tt>&nbsp; &nbsp;E.g. set :x3 = 2.3;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set :i = 2 +
          sqrt(:x3);</tt></p>
    </ul>
    <a name="constants"></a>
    <h3> Constants</h3>
    Constants can be integers, reals, strings, time stamps, booleans, or
    <tt>nil</tt>.<br>
    Syntax:
    <pre><font face="Courier New, Courier, monospace">constant ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer-constant | real-constant | boolean-constant |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#string-constant">string-constant</a> | <a href="#timestamp">time-stamp</a> | <a href="#functional-constant">functional-constant</a> </font><font><font face="Courier New, Courier, monospace">| 'nil'<br></font></font><font face="Courier New, Courier, monospace"><br><a name="integer-constant"></a>integer-constant ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['-'] digit-list&nbsp;<br> <br>   E.g. 123<br>        -123<br> <br><a name="real-constant"></a>real-constant ::=<br>        decimal-constant | scientific-constant<br><br>decimal-constant ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['-'] digit-list '.' [digit-list]<br><br>scientific-constant ::=<br>        decimal-constant ['e' | 'E'] integer-constant<br> <br>   E.g. 1.2<br>        -1.0<br>        2.3E2<br>        -2.4e-21<br> <br>boolean-constant ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'true' | 'false' </font><br></pre>
    <span style="font-family: monospace;"></span>The constant <span
      style="font-style: italic;">false </span>is <span
      style="font-style: italic;">nil</span> casted to type <span
      style="font-style: italic;">Boolean</span>. The only legal boolean
    value that can be stored in the database is <span
      style="font-style: italic;">true</span> and a boolean value is
    regarded as <span style="font-style: italic;">false </span>if it
    is not in the database (close world assumption).<br>
    <br>
    <font face="Courier New, Courier, monospace"><a
        name="string-constant"></a><small>string-constant ::=&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string-separator
        character-list string-separator<br>
        <br>
        <a name="string-separator"></a>string-separator ::=&nbsp;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''' | '"'<br>
        <br>
        E.g. "A string"<br>
        'A string'<br>
        'A string with "'<br>
        "A string with \" and '"</small> </font><br>
    The enclosing string separators (' or ") for a string constant must
    be the same. If the string separator is " then \ is the <i>escape
      character</i> inside the string, replacing the succeeding
    character. For example the string 'ab"\' can also be written as
    "ab\"\\", and the string a'"b must be written as "a'\"b".<br>
    <br>
    <tt><a name="simple-value"></a>simple-value ::= constant | variable<br>
      <br>
      &nbsp; &nbsp;E.g. :MyInterfaceVariable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyLocalVariable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 123<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Hello World"<br>
    </tt>
    <h3></h3>
    A simple value is either a constant or a variable reference.<br>
    <br>
    <h3><a name="expressions"></a>Expressions</h3>
    <tt>expr ::= &nbsp;<a href="#simple-value">simple-value</a> | <a
        href="#function-call">function-call</a> | <a
        href="#collections">collection </a>| <a href="#casting">casting</a>
      | <a href="#vector-index">vector-indexing</a> <br>
      &nbsp; &nbsp; E.g. 1.23<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1+2<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&lt;2 and 1&gt;3<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqrt(:a) + 3 * :b<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
        href="#vectors">{1,2,3}</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
        href="#casting">cast(:p as Student)</a></tt><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




    <a href="#vector-index">a[3]</a><br>
    <br>
    An expression is either a constant, a variable, or a function call.
    An expression has a computed <span style="font-style: italic;">value</span>.
    The value of an expression is computed if the expression is entered
    to the Amos II top loop, e.g.:<br>
    <br>
    <tt>&nbsp; &nbsp;1+5*sqrt(6);<br>
      &nbsp; &nbsp; =&gt; 13.2474487139159</tt><br>
    <br>
    Notice that Boolean expressions either return <span
      style="font-style: italic;">true</span>, or nothing if the
    expression is not true. For example:<br>
    <span style="font-family: monospace;">&nbsp;&nbsp; 1&lt;2 or 3&lt;2;</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; =&gt; TRUE</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp; 1&lt;2 and
      3&lt;2;</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; =&gt;
      nothing</span><br>
    <br>
    Entering simple expressions is the simplest form of AmosQL <a
      href="#query-statement"><span style="font-style: italic;">queries</span></a>.<br>
    <br>
    <h3><a name="collection-syntax"></a>Collections</h3>
    <tt>collection ::= bag-expr | vector-expr<br>
      bag-expr ::= bag(<a href="#expressions">expr-commalist</a>)<br>
      &nbsp; E.g.: bag(1,2,3)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bag(1,:x+2)<br>
      <br>
      vector-expr ::= '{' <a href="#expressions">expr-comma-list</a>
      '}'<br>
      &nbsp; E.g.: {1,2,3}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{1,2},{3,4}}<br>
      &nbsp; &nbsp; &nbsp; &nbsp; {1,name(:p),1+sqrt(:a)}<br>
    </tt><br>
    <a href="#collections">Collections</a> represent sets of objects.
    Collections can be either bags (type <span style="font-style:
      italic;">Bag</span>) or vectors (type <span style="font-style:
      italic;">Vector</span>):<br>
    <ul>
      <li>&nbsp;<span style="font-style: italic;"><a
            href="#bag-semantics">Bags</a> </span>are unordered sets of
        objects with duplicates allowed. The value of a query is by
        default a bag. When a query returns a bag the elements of the
        bag are printed on separate lines, for example:<br>
        <span style="font-family: monospace;">&nbsp; Amos 2&gt; select
          name(p) from Person p;</span><br style="font-family:
          monospace;">
        <span style="font-family: monospace;">&nbsp; "Bill"</span><br
          style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; "Carl"</span><br
          style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; "Adam"</span><br>
        <br>
      </li>
      <li>&nbsp;<a href="#vectors"><span style="font-style: italic;">Vectors</span></a>
        are sequences of objects of any kind. Curly brackets {} enclose
        vector elements, for example:<br>
        <span style="font-family: monospace;">&nbsp; Amos 1&gt; set
          :v={1,2,3};</span><br style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; Amos 2&gt; :v;</span><br
          style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp; {1,2,3}</span><br>
      </li>
    </ul>
    <h3><a name="statements"></a> Statements</h3>
    Statements instruct Amos II to perform various kinds of services.
    The following statements can be entered to the Amos II top loop:
    <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#types">create-type-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#delete-type">delete-type-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#create-object">create-object-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#object-deletion">delete-object-stmt</a> | <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#function-definitions">create-function-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#deletef">delete-function-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#query-statement">query</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#updates">update-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#add-type">add-type-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#add-type">remove-type-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#foreach-statement">for-each-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#interface-vardecl">set-interface-variable-stmt</a> |&nbsp;<br>        <a href="#interface-vardecl">declare-interface-variable-stmt</a> |<br>        <a href="#commit">commit-stmt</a> |<br>        <a href="#rollback">rollback-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cursors">open-cursor-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cursors">fetch-cursor-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#cursors">close-cursor-stmt</a> |<br>        <a href="#miscellaneous">quit-stmt</a> |<br>        <a href="#miscellaneous">exit-stmt</a> <a href="#procedures"></a></pre>
    <h2><a name="types"></a> 2.1 Types</h2>
    The <span style="font-style: italic;">create type </span>statement
    creates a new type in the database.
    <p>Syntax:&nbsp; </p>
    <pre>create-type-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'create type' <a href="#type-name">type-name</a> ['under' <a href="#type-name">type-name-commalist</a>]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['properties' '(' attr-function-commalist ')']<br><br>type-spec ::= <a href="#type-name">type-name</a> | 'Bag of' type-spec | 'Vector of' type-spec<br><br><a name="type-name"></a>type-name ::= <a href="file:///C:/AmosNT/doc/amos_users_guide.html#Identifiers">identifier</a><br><br>attr-function ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#function-definitions">generic-function-name</a> type-spec ['key']<br> <br>   E.g. create type Person;<br>        create type Employee under Person;<br>        create type Student under Person;<br>        create type Kid under Person properties<br>         (name Charstring key,<br>          attitude Integer);<br></pre>
    Type names must be unique in the database.<br>
    Type names are <b>not </b>case sensitive and the type names are
    always internally <i>upper-cased</i>. For clarity all type names
    used in examples in this manual always have the first letter
    capitalized.<br>
    <p>The new type will be a subtype of all the supertypes in the '<tt>under'</tt>
      clause. If no supertypes are specified the new type becomes a
      subtype of the system type named <tt>Userobject</tt>. <i>Multiple




        inheritance</i> is specified through more than one supertype,
      for example:<br>
    </p>
    <pre>   create type TA under Student, Employee;<br></pre>
    <p> </p>
    <p>The <tt>attr-function-commalist</tt> clause is optional, and
      provides a way to define attributes for the new type. Each
      attribute is a <a href="#function-definitions">function</a>
      having a single argument and a single result. An attribute is
      represented as a <a href="#function-definitions">stored function</a>
      in the local database. The argument type of an attribute function
      is the type being created and the result type is specified by the<tt>
        type-spec</tt>. The result type must be previously defined. In
      the above example the function <span style="font-family:
        monospace;">name</span> has the argument of type <span
        style="font-family: monospace;">Person</span> and result of type
      <span style="font-family: monospace;">Charstring</span>.<br>
    </p>
    <p>If '<span style="font-family: monospace;">key</span>' is
      specified for a property, it indicates that each value of the
      attribute is unique and the system will raise an error if this <a
        href="#cardinality-constraints">uniqueness is violated</a>. In
      the example, two objects of type <span style="font-family:
        monospace;">Person</span> cannot have the same value of
      attribute <span style="font-family: monospace;">name</span>.<br>
      &nbsp;</p>
    <h3><a name="delete-type"></a> 2.1.1 Deleting types</h3>
    The <tt>delete type</tt> statement deletes a type and all its
    subtypes.&nbsp;
    <p>Syntax: </p>
    <pre>delete-type-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'delete type' <a href="#type-name">type-name</a><br> <br>   E.g. delete type Person;<br></pre>
    If the deleted type has subtypes they will be deleted as well, in
    this case types <span style="font-family: monospace;">Employee</span>,
    <span style="font-family: monospace;">Student</span>, and <span
      style="font-family: monospace;">Kid</span>. Functions using the
    deleted types will be deleted as well.<br>
    <h2><a name="create-object"></a> 2.2 Objects</h2>
    The <tt>create object</tt> statement creates one or more objects
    and makes the new object(s) instance(s) of a given user type and all
    its supertypes.
    <p>Syntax:&nbsp; </p>
    <pre>create-object-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'create' <a href="#type-name">type-name</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['(' <a href="#function-definitions">generic-function-name-commalist</a> ')'] 'instances' initializer-commalist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>initializer ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#variables">variable</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<a href="#variables">variable</a>] '(' <a href="#expressions">expr-commalist</a> ')'<br><br></pre>
    Examples:
    <pre>&nbsp;<br>&nbsp;&nbsp; create Person (name,age) instances<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#interface-vardecl">:adam</a> ('Adam',26),:eve ('Eve',32);<br><br>&nbsp;&nbsp; create Person instances :olof;<br><br>&nbsp;&nbsp; create Person (parents) instances<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :tore (<a href="#collections">bag(:adam,:eve)</a>);<br><br>   create Person (name,age) instances<br>          ("Kalle "+"Persson" , 30*1.5);<br></pre>
    The new objects are assigned initial values for the specified
    attributes. The attributes can be any <a href="#updates">updatable</a>
    AmosQL functions of a single argument and value.
    <p>One object will be created for each initializer. Each initializer
      can have an optional variable name which will be bound to the new
      object. The variable name can subsequently be used as a reference
      to the object. </p>
    <p>The initializer also contains a comma-separated list of initial
      values for the specified functions in <a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#function-definitions">generic-function-name-commalist</a>.</p>
    <p>Initial values are specified as <a href="#expressions">expressions</a>.
    </p>
    <p>The types of the initial values must match the declared result
      types of the corresponding functions. </p>
    <p><a href="#bag-semantics">Bag valued functions</a> are initialized
      using the syntax <tt>'bag(e1,...)'</tt> (syntax <a
        href="#collections"><tt>bag-expr</tt></a>). </p>
    <p>Vector result functions are formed with a comma-separated list of
      values enclosed in curly brackets (syntax <a
        href="#collection-syntax"><tt>vector-expr</tt></a>). </p>
    <p>It is possible to specify <tt>nil</tt> for a value when no
      initialization is desired for the corresponding function.<br>
    </p>
    <h3><a name="object-deletion"></a><span style="font-weight: bold;"></span>2.2.1




      Deleting objects</h3>
    <p></p>
    Objects are deleted from the database with the <tt>delete</tt>
    statement.
    <p>Syntax: </p>
    <pre>delete-object-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'delete' <a href="#variables">variable</a></pre>
    The system will automatically remove the deleted object from all
    stored functions where it is referenced.&nbsp;
    <p>Deleted objects are printed as </p>
    <pre>#[OID nnn *DELETED*]</pre>
    The objects may be undeleted by <tt>rollback</tt>. An automatic
    garbage collector physically removes an OID from the database only
    if its creation has been rolled back or its deletion committed, <span
      style="font-style: italic;">and </span>it is not references from
    some variable or external system.<br>
    <h2><a name="query-statement"></a><span style="font-weight: bold;"></span>2.3




      Queries</h2>
    Queries retrieve objects having specified properties. They are
    specified using the <span style="font-style: italic;">query
      statement</span> denoting either&nbsp; function calls, select
    statements, or variable references.<br>
    <br>
    <tt>query ::= <a href="#select-statement">select-stm</a><a
        href="#select-statement">t</a> | function-call | <a
        href="#expressions">expr</a></tt><br>
    <pre></pre>
    <p> </p>
    <h3><a name="function-call"></a> 2.3.1 Function calls</h3>
    A simple form of queries are calls to functions. Syntax:
    <pre><br>function-call ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#function-name">function-name</a> '(' [parameter-value-commalist] ')' |<br>        <a href="#expressions">expr</a> infix-operator <a href="#expressions">expr</a> |<br>        tuple-expr<br><br>infix-operator ::= '+' | '-' | '*' | '/' | '&lt;' | '&gt;' | '&lt;=' | '&gt;=' | '=' | '!=' | 'in'<br> <br><br>parameter-value ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#expressions">expr</a> | <br>        '(' <a href="#select-statement">select-stmt</a> ')' |<br>        tuple-expr<br><br><a name="tuple-expr"></a>tuple-expr ::= '(' expr-commalist ')'<br><br><br>   E.g. sqrt(2.1);<br>        1+2;<br>        1+2 &lt; 3+4;<br>       &nbsp;"a" + 1;&nbsp;  <br></pre>
    <a name="infix-functions"></a>The built-in functions <tt>plus,minus,times,divide</tt>
    have infix syntax +,-,*,/ with the usual priorities.&nbsp; <br>
    For example:
    <pre>&nbsp;(income(:eve) + income(:ulla)) * 0.5;</pre>
    is equivalent to:
    <pre>&nbsp;times(plus(income(:eve),income(:ulla)),0.5);</pre>
    The '+' operator is defined for both numbers and strings. For
    strings it implements string concatenation.&nbsp;
    <p>In a function call, the types of the actual parameters and
      results must be the same as, or subtypes of, the types of the
      corresponding formal parameters or results. <br>
    </p>
    <p><a href="#tuple-expr">Tuple expressions</a> are used for <a
        href="#tuple-assignment">assigning values</a> of <a
        href="#tuple-result">tuple valued functions</a> in queries.<br>
    </p>
    <h3><a name="select-statement"></a> 2.3.2 The select statement</h3>
    The <i>select statement</i> provides the most flexible way to
    specify queries.
    <p>Syntax: </p>
    <pre>select-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'select' ['distinct'] <a href="#expressions">expr-commalist</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  [into-clause]&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  [from-clause]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  [where-clause]<br><br>into-clause ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'into' <a href="#variables">variable-commalist</a>&nbsp;<br><br>from-clause ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'from' <a href="#variable-declaration">variable-declaration-commalist</a>&nbsp;<br><br><a name="variable-declaration"></a>variable-declaration ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#types">type-spec</a> <a href="#variables">local-variable</a><br><br><a name="where-clause"></a>where-clause ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'where' <a href="#predicate-expressions">predicate-expression</a><br><br>   For example:<br><br>      select name(p) <br>      from Person p <br>      where age(p)&lt;2 and <br>            city(p)="Uppsala";  <br><br>      select income(x),income(father(x))+income(mother(x)) <br>      from Person x<br>      where name(p) = "Carl"; /* Returns bag of tuples */<br><br>      select {income(x),income(father(x))+income(mother(x))} <br>      from Person x<br>      where name(p) = "Carl"; /* Returns bag of <a href="#vectors">vectors</a> constructed using {....} notation */</pre>
    The<tt> expr-commalist</tt> defines the object(s) to be retrieved.
    <p>The<tt> from-clause</tt> declares types of local variables used
      in the query.&nbsp; </p>
    <p>The <tt>where-clause</tt> gives selection criteria for the
      search. The where clause is specified as a <a
        href="#predicate-expressions">predicate expression</a> having a
      boolean value.<span style="text-decoration: underline;"></span><a
        href="#predicates"></a> </p>
    <p>The result of a select statement is a bag of single result
      tuples. Duplicates are removed only when the keyword 'distinct' is
      specified, in which case a set (rather than a bag) is returned.
      The <span style="font-style: italic;">in</span> operator can be
      used for extracting the values in a <a href="#bag-semantics">bag</a>.<br>
      <br>
      For example:<br>
    </p>
    <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
select




        distinct friends(p)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from Person p<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where "Carl" in name(parents(p));<br>
      </span> </p>
    <p>The optional <span style="font-style: italic;">into-clause</span>
      specifies variables to be bound to the result.&nbsp;<span
        style="font-weight: bold;"></span> </p>
    <p>For example: </p>
    <pre>&nbsp;     select p into :eve2 from Person p where name(p) = 'Eve';<br>&nbsp;     name(:eve2);</pre>
    This query retrieves into the environment variable <span
      style="font-style: italic;">:eve2</span> the Person whose name is<tt>
    </tt><span style="font-style: italic;">'Eve'</span>. <br>
    <span style="font-weight: bold;"><br>
      NOTICE</span> that if more than one object is retrieved the <span
      style="font-style: italic;">into </span>variable(s) will be bound
    only to the <span style="font-style: italic;">first</span>
    retrieved tuple. In the example, if more that one person is named
    Eve the first one retrieved will be assigned to <span
      style="font-style: italic;">:eve2</span>. <br>
    <br>
    <a name="tuple-assignment"></a>To assign the results of <a
      href="#tuple-result">tuple valued functions</a> in queries, use <a
      href="#tuple-expr">tuple expressions</a>, e.g.<br>
    <br>
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      select m, f from Person m, Person p where (m,f) = parents2(:p);</span><br>
    <br>
    If you wish to assign the entire result from the select statement in
    a variable, enclose it in parentheses. The result will be a <a
      href="#bag-semantics">bag</a>. (set with duplicates). The elements
    of the bag can then be extracted with the <span style="font-style:
      italic;">in</span> function or the infix in operator:<br>
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      set :r = (select p from Person p where name(p) = 'eve');<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in(:r);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select p in :r from Person p;</span><span
      style="font-family: monospace;"></span><br>
    <p><a name="predicates"></a> </p>
    <h3><a name="predicate-expressions"></a> 2.3.3 Predicate expressions</h3>
    Predicate expressions are expressions returning boolean values. The
    <a href="#where-clause">where clauses</a> of queries are predicate
    expressions. The boolean operators <span style="font-style:
      italic;">and </span>and <span style="font-style: italic;">or</span>
    can be used to combine boolean values. The general syntax of a
    predicate expression is:
    <pre>predicate-expression ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; predicate-expression 'and' predicate-expression |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; predicate-expression 'or' predicate-expression |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(' predicate-expression ')' |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="amos_users_guide.html#function-call">expr</a><br><br><big><span style="font-family: Times New Roman,Times,serif;">For example:</span></big>   <br>	x &lt; 5<br>        child(x)<br><span style="font-family: monospace;">        "a" != s</span><br>        home(p) = "Uppsala" and name(p) = "Kalle"<br><span style="font-family: monospace;">        name(x) = "Carl" and child(x)</span><br><span style="font-family: monospace;">        x &lt; 5 or x &gt; 6 and 5 &lt; y</span> <br><span style="font-family: monospace;">        1+y &lt;= sqrt(5.2)</span>       <br>        parents2(p) = (m,f) <br><span style="font-family: monospace;">        count(select friends(x) from Person x where child(x)) &lt; 5<br></span><big><span style="font-family: Times New Roman,Times,serif;"><br>The boolean operator <span style="font-style: italic;">and</span> has precedence over <span style="font-style: italic;">or</span>. <br>For example:</span></big><span style="font-family: monospace;"><br>	a&lt;2 and a&gt;3 or b&lt;3 and b&gt;2<br></span><big><span style="font-family: Times New Roman,Times,serif;">is equivalent to</span></big><span style="font-family: monospace;"><br>	</span><span style="font-family: monospace;">(a&lt;2 and a&gt;3) or (b&lt;3 and b&gt;2)</span></pre>
    <span style="font-family: monospace;"></span><span
      style="font-family: monospace;"></span>
    <p>The comparison operators (=, !=, &lt;, &lt;=, and &gt;=) are
      treated as binary <a href="#boolean-function">boolean functions</a>.
      You can compare objects of any type.<br>
    </p>
    <p>Predicate expressions are allowed in the result of a select
      expression.<br>
      For example, the query:<br>
      <span style="font-family: monospace;">select age(:p1) &lt; 20 and
        home(:p1)="Uppsala";</span><br>
      or simply<br>
      <span style="font-family: monospace;">age(:p1) &lt; 20 and
        home(:p1)="Uppsala";</span><br>
      returns <span style="font-style: italic;">true</span> if person <span
        style="font-style: italic;">:p1</span> is younger than 20 and
      lives in Uppsala. <br>
    </p>
    <p>The query:<br>
      <span style="font-family: monospace;">select age(x)&lt;40 from
        Person x;</span><br>
      returns the same number of <span style="font-style: italic;">true</span>
      values as there are persons in the database whose age is less than
      40.<br>
    </p>
    <h3><a name="quantifiers"></a>2.3.4 Quantifiers<br>
    </h3>
    <p>The function <span style="font-style: italic;">some </span>implements




      logical exist over a subquery. <br>
      To test if a subquery <span style="font-style: italic;">sq</span>
      returns empty result use <span style="font-style: italic;">some</span>:<br>
    </p>
    <pre>some(Bag sq) -&gt; Boolean</pre>
    for example<br>
    <pre>select name(p) from Person p where some(parents(p));</pre>
    <br>
    The function <span style="font-style: italic;">notany</span>
    implements logical not exist over a subquery. <br>
    To test if a subquery <span style="font-style: italic;">sq</span>
    returns empty result, i.e. negation, use <span style="font-style:
      italic;">notany</span>:<br>
    <pre>notany(Bag sq) -&gt; Boolean</pre>
    for example<br>
    <pre>select name(p) from Person p where notany(select parents(p) where age(p)&gt;65);</pre>
    <br>
    The function <span style="font-style: italic;">ifsome</span>
    implements an if-then-else over a subquery.<br>
    To select different results depending on whether of not a subquery <span
      style="font-style: italic;">sq</span> returns non-empty result use
    <span style="font-style: italic;">ifsome</span>:<br>
    <pre>ifsome(Bag sq, Object t, Object e) -&gt; Object r</pre>
    <br>
    If <span style="font-style: italic;">sq</span> is empty <span
      style="font-style: italic;">t</span> is returned, otherwise <span
      style="font-style: italic;">e</span>. The type of&nbsp; the result
    <span style="font-style: italic;">r</span> is the most specific
    common supertype of <span style="font-style: italic;">t</span> and
    <span style="font-style: italic;">e</span>.
    <p><br>
    </p>
    <h2><a name="function-definitions"></a><span style="font-weight:
        bold;"></span>2.4 Functions</h2>
    The<span style="font-style: italic;"> create function</span>
    statement defines a new user function. Functions can be defined as
    one of the following:
    <ul>
      <li><a href="amos_users_guide.html#stored-function"><i>Stored
            functions</i></a> whose extents are explicitly stored in the
        Amos II database as a table. <br>
      </li>
      <li><a href="amos_users_guide.html#derived-function"><i>Derived
            functions</i></a> which are defined by a single <a
          href="amos_users_guide.html#query-statement">query</a>. A
        derived function is a parameterized view. <br>
      </li>
      <li><a href="amos_users_guide.html#foreign-functions"><i>Foreign
            functions</i></a> which are defined in a programming
        language. They provide foreign function interfaces to the
        programming languages C/C++ <a
          href="amos_users_guide.html#Ris00a">[Ris00a]</a>, Java <a
          href="amos_users_guide.html#ER00">[ER00]</a>, and Lisp <a
          href="amos_users_guide.html#Ris00a">[Ris00a]</a> <a
          href="amos_users_guide.html#Ris00b">[Ris00b]</a>. </li>
      <li><a href="amos_users_guide.html#procedures"><i>Procedural
            functions</i></a> which are functions defined using
        procedural AmosQL statements. Procedural functions makes AmosQL
        computationally complete. <br>
      </li>
      <li><a href="amos_users_guide.html#overloaded-functions"><i>Overloaded




            functions</i></a> which are functions having different
        implementations depending on the argument types in a function
        call. </li>
    </ul>
    <p>Syntax: </p>
    <tt>create-function-stmt ::=<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'create function'
      generic-function-name argument-spec '-&gt;' result-spec [<a
        href="amos_users_guide.html#fn-implementation">fn-implementation</a>]<br>
    </tt><tt><br>
      &nbsp; &nbsp;E.g. create function born(Person) -&gt; Integer as
      stored;<br>
      <br>
    </tt><tt> <a name="generic-function-name"></a>generic-function-name
      ::= <a href="amos_users_guide.html#Identifiers">identifier</a><br>
      <br>
      <br>
      <a name="function-name"></a>function-name ::= <a
        href="amos_users_guide.html#generic-function-name">generic-function-name</a>
      |<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      type-name-list '.' <a
        href="amos_users_guide.html#generic-function-name">generic-function-name</a>
      '-&gt;' type-name-list<br>
    </tt><tt><br>
      &nbsp; &nbsp;E.g. <a href="#infix-functions">plus</a><br>
      &nbsp; &nbsp; &nbsp; &nbsp; <br>
      <br>
    </tt>Function names are <b>not </b>case sensitive and are
    internally stored <i>upper-cased</i>. <br>
    <br>
    <tt>type-name-list ::= <a href="amos_users_guide.html#types">type-name</a>
      | <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      <a href="amos_users_guide.html#types">type-name</a> '.'
      type-name-list <br>
    </tt><br>
    The types used in the function signatures must be previously
    defined. <br>
    <tt><br>
      argument-spec ::='(' [argument-declaration-commalist] ')'&nbsp;<br>
      <br>
      argument-declaration ::= <a href="amos_users_guide.html#types">type-spec</a>
      [<a href="amos_users_guide.html#variables">local-variable</a>]
      [key-constraint]<br>
    </tt><br>
    All names of the argument and result parameters for a given function
    definition must be different.<br>
    <tt><br>
      <a href="amos_users_guide.html#cardinality-constraints">key-constraint</a>
      ::= ('key' | 'nonkey')<br>
      <br>
      result-spec ::=&nbsp;&nbsp; argument-spec |
      tuple-result-spec&nbsp;<br>
      <br>
      <a name="tuple-result"></a>tuple-result-spec ::= ['Bag of'] '('
      argument-declaration-commalist ')'&nbsp;<br>
      <br>
      <a name="fn-implementation"></a>fn-implementation ::=&nbsp;&nbsp;
      'as' (<a href="amos_users_guide.html#query-statement">query</a> |
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




    </tt><tt>'stored' |</tt><br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      <a href="amos_users_guide.html#procedure-body">procedural-function-definition</a>
      |<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      <a href="amos_users_guide.html#fn-implementation">foreign-function-definition</a>)
      <br>
      <br>
      <br>
    </tt><a name="function-signature"></a>The<tt> argument-spec</tt> and
    the <tt>result-spec</tt> together specify the <i>signature</i> of
    the function, i.e. the types and optional names of formal parameters
    and results.&nbsp; <br>
    <br>
    <a name="stored-function"></a>A <span style="font-style: italic;">stored




      function</span> is defined by the implementation '<span
      style="font-family: monospace;">as stored</span>'. <br>
    <ul>
      <li>For example:</li>
    </ul>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create function
      age(Person p) -&gt; Integer a as stored;<br>
    </tt>
    <ul>
      <li>The name of an argument or result parameter can be left
        unspecified if it is not referenced in the function's
        implementation. <br>
        For example:<span style="font-family: monospace;"><br>
          <br>
          &nbsp;&nbsp; </span><tt>create function name(Person) -&gt;
          Charstring as stored;<br>
          <br>
        </tt></li>
      <li><tt>'Bag of'</tt> specifications on a single result parameter
        of a stored function declares the function to return a bag of
        values, i.e. a set with tuples allowed. <br>
        For example:<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp; <tt>create function parents(Person)
          -&gt; Bag of Person as stored;</tt> <br>
        <br>
      </li>
      <li>
        <p>AmosQL functions may also have tuple valued results by using
          the <a href="amos_users_guide.html#tuple-result">tuple-result-spec</a>
          notation. For example:<br>
        </p>
        <span style="font-family: monospace;">&nbsp; create function
          parents2(Person p) -&gt; (Person m, Person f) as stored;<br>
          <br>
          &nbsp; create function marriages(Person p)<br>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
          &nbsp;&nbsp; -&gt; Bag of (Person spouse, Integer year) as
          stored;<br>
        </span></li>
      <li><a href="amos_users_guide.html#tuple-expr">Tuple expressions </a>are




        used for binding the results of tuple valued functions in
        queries, for example:<br>
        <br>
        <span style="font-family: monospace;">&nbsp; select s,y from
          Person s, Integer y where (s,y) in marriages(:p);&nbsp; &nbsp;
          <br>
        </span></li>
    </ul>
    &nbsp;<br>
    <a name="derived-function"></a>A <span style="font-style: italic;">derived




      function</span> is defined by a single AmosQL&nbsp;<span
      style="text-decoration: underline;"></span><a
      href="amos_users_guide.html#query-statement">query</a> as
    implementation. <br>
    <ul>
      <li>For example:</li>
    </ul>
    &nbsp;<tt> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; create function
      netincome(Person p) -&gt; Number<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      as income(p) - taxes(p);</tt><br>
    <ul>
      <li><i><a name="boolean-function"></a>Boolean functions</i>&nbsp;
        return <span style="font-style: italic;">true</span><tt> </tt>or
nothing




        (<span style="font-style: italic;">nil</span>). <br>
        For example:<br>
      </li>
    </ul>
    <pre><tt>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; create function child(Person p) -&gt; Boolean<br></tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as select true where age(p)&lt;18;<br></pre>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>alternatively:<br>
    <pre>         create function child(Person p) -&gt; Boolean<br>            as age(p) &lt; 18;<br></pre>
    <tt></tt>
    <ul>
      <li><a name="implicit-bag"></a>Since the select statement returns
        a bag of values, derived functions also often return a&nbsp; <tt>Bag




          of</tt> results. If you know that a function returns a bag of
        values you should indicate that in the signature. <br>
        For example:<br>
        <span style="font-family: monospace;"></span>
        <pre>   create function youngFriends(Person p)-&gt; Bag of Person<br>     as select f<br>        from Person f<br>        where age(f) &lt; 18<br>          and f in friends(p);<span style="font-family: monospace;"></span><br></pre>
        If you write:
        <pre><span style="font-family: monospace;">        create function youngFriends(Person p)-&gt; Person<br>&nbsp;&nbsp;&nbsp;&nbsp;      as select f<br>             from Person f<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      where age(f) &lt; 18<br>               and f in friends(p);<br></span></pre>
        you indicate to the system that <span style="font-style:
          italic;">youngFriends</span> returns a single value. However,
        this constraint is not enforced by the system so if there are
        more that one <span style="font-style: italic;">youngFriends</span>
        the system will treat the result as&nbsp; a bag.<br>
        <pre><span style="font-family: monospace;"></span><span style="font-family: monospace;"></span></pre>
      </li>
    </ul>
    <ul>
      <li>Variables declared in the result of a derived function need
        not be declared again in the from clause. For example, <span
          style="font-style: italic;">youngFriends</span> can also be
        defined as<span style="font-family: monospace;"></span><br>
        <pre><span style="font-family: monospace;">&nbsp;&nbsp; create function youngFriends(Person p)-&gt; Bag of Person f<br>          as select f<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      where age(f) &lt; 18<br>               and f in friends(p);</span></pre>
      </li>
      <li> <span style="font-weight: bold;">Notice</span> that the
        variable <span style="font-style: italic;">f</span> is bound to
        the elements of the bag, not the bag itself. This definition is
        equivalent:<br>
      </li>
    </ul>
    <pre><span style="font-family: monospace;">        create function youngFriends(Person p)-&gt; Bag of (Person f)<br>&nbsp;&nbsp;&nbsp;&nbsp;      as select f<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      where age(f) &lt; 18<br>               and f in friends(p);</span></pre>
    <ul>
      <br>
      <li><a name="daplex-semantics"></a>If a function is applied on the
        result of a function returning a bag of values, the outer
        function is applied on each element of that bag, the bag is <span
          style="font-style: italic;">flattened</span>. This is called <span
          style="font-style: italic;">Daplex semantics</span>. See also
        <a href="amos_users_guide.html#bag-semantics">Bags</a>. For
        example:</li>
    </ul>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create function
      grandparents(Person p) -&gt; Bag of Person<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as
      parents(parents(p));<br>
      &nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp; </tt>If there are two parents per parent
    generation of Carl there will be four names returned when querying:<tt><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select
      name(grandparents(q)) from Person q where name(q)= "Carl";<br>
    </tt>
    <ul>
      <li> Derived functions can also have <span style="font-style:
          italic;">arguments</span> declared <tt>'Bag of'</tt> making
        them <a href="amos_users_guide.html#subqueries">aggregate
          functions</a>. <br>
        For example:<br>
        <br>
        <span style="font-family: monospace;">&nbsp;&nbsp; create
          function myavg(Bag of Number x) -&gt; Number<br>
          &nbsp;&nbsp;&nbsp;&nbsp; as sum(x)/count(x);<br>
          <br>
        </span></li>
      <li><a href="#subqueries">Aggregate functions</a> do not flatten
        the argument bag. For example, the following query computes the
        average age of Carl's grandparents:<br>
        <span style="font-family: monospace;"> <br>
          &nbsp;&nbsp; select myavg(age(grandparents(q))) from Person
          p where name(q)="Carl";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><br>
      </li>
    </ul>
    <ul>
      <li>When tuple valued functions are called the values are picked
        by enclosing the function values within parentheses (..) through
        the <a href="amos_users_guide.html#tuple-expr">tuple-expr</a>
        syntax. For example:<br>
      </li>
    </ul>
    <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
select
age(m),




        age(f<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from Person m, Person f,
        Person p<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where (m,f) = parents2(p)
        and<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        name(p) = "Oscar";</span>&nbsp;<br>
    </p>
    <ul>
      <li>The value of a bag valued function can be saved in a bag and
        extracted using <span style="font-style: italic;">in</span>,
        e.g.:</li>
    </ul>
    <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
set




        :par = parents(:p);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in(:par);</span><br>
    </p>
    <h3><a name="deletef"></a> 2.4.1 Deleting functions</h3>
    Functions are deleted with the <tt>delete function</tt> statement.
    <p>Syntax: </p>
    <pre>delete-function-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'delete function' <a href="amos_users_guide.html#function-name">function-name</a></pre>
    For example:
    <pre>&nbsp;  delete function married;</pre>
    Deleting a function also deletes all functions calling the deleted
    function.<br>
    <h1> </h1>
    <p></p>
    <h3><a name="overloaded-functions"></a><span style="font-weight:
        bold;"></span>2.4.2 Overloaded functions</h3>
    Function names may be <span style="font-style: italic;">overloaded</span>,
    i.e., functions having the same name may be defined differently for
    different argument types. This allows <span style="font-style:
      italic;">generic</span> functions applicable on objects of several
    different argument types. Each specific implementation of an
    overloaded function is called a <i>resolvent</i>.
    <p>For example, assume the two following Amos II function
      definitions having the same <span style="font-style: italic;">generic</span>
      function name <span style="font-family: monospace;">less</span>:
    </p>
    <pre>create function less(Number i, Number j)-&gt;Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as i &lt; j;&nbsp;<br>create function less(Charstring s,Charstring t)-&gt;Boolean&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as s &lt; t;</pre>
    Its resolvents will have the signatures:
    <pre>&nbsp; less(Number,Number) -&gt; Boolean<br>&nbsp; less(Charstring,Charstring) -&gt; Boolean</pre>
    Internally the system stores the resolvents under different function
    names. The name of a resolvent is obtained by concatenating the type
    names of its arguments with the name of the overloaded function
    followed by the symbol '-&gt;' and the type of the result. The two
    resolvents above will be given the internal resolvent names <span
      style="font-family: monospace;">NUMBER.NUMBER.LESS-&gt;BOOLEAN</span>
    and <tt>CHARSTRING.CHARSTRING.LESS-&gt;BOOLEAN</tt>.&nbsp;
    <p>The query compiler resolves the correct resolvent to apply based
      on the types of the arguments; the type of the result is <span
        style="font-style: italic;">not </span>considered. If there is
      an ambiguity, i.e. several resolvents qualify in a call, or if no
      resolvent qualify, an error will be generated by the query
      compiler. </p>
    <p>When overloaded function names are encountered in AmosQL function
      bodies, the system will try to use local variable declarations to
      choose the correct resolvent (early binding).&nbsp; <br>
      For example: </p>
    <pre>&nbsp;create function younger(Person p,Person q)-&gt;Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as less(age(p),age(q));</pre>
    will choose the resolvent<tt> </tt><span style="font-family:
      monospace;">NUMBER.NUMBER.LESS-&gt;BOOLEAN</span>, since <tt>age</tt>
    returns integers and the resolvent <span style="font-family:
      monospace;">NUMBER.NUMBER.LESS-&gt;BOOLEAN</span> is applicable to
    integers by inheritance. The other function resolvent <tt>CHARSTRING.CHARSTRING.LESS-&gt;BOOLEAN</tt>
    does not qualify since it is not legal to apply to arguments of type
    <tt>Integer</tt>.
    <p>On the other hand, this function: </p>
    <pre>create function nameordered(Person p,Person q)-&gt;Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as less(name(p),name(q));</pre>
    will choose the resolvent <span style="font-family: monospace;">NUMBER.NUMBER.LESS-&gt;BOOLEAN</span>
    since the function <span style="font-family: monospace;">name</span>
    returns a string. In both cases the <span style="font-style:
      italic;">type resolution</span> (selection of resolvent) will be
    done at compile time. <a name="late-binding"></a>
    <p><span style="font-weight: bold;">Late binding</span><br>
      <br>
      Dynamic type resolution at run time, <i>late binding</i>, is done
      for top loop function calls to choose the correct resolvent. For
      example, the query<br>
    </p>
    <pre>less(1,2);</pre>
    will choose <span style="font-family: monospace;">NUMBER.NUMBER.LESS-&gt;BOOLEAN</span>
    based on the numeric types the the arguments.<br>
    <br>
    Inside function definitions and queries there may also be
    expressions requiring late bound overloaded functions. For example,
    suppose that managers are employees whose incomes are the sum of the
    income as a regular employee plus some manager bonus:&nbsp;
    <pre>&nbsp;create type Employee under Person;<br>&nbsp;create type Manager under Employee;<br>&nbsp;create function mgrbonus(Manager)-&gt;Integer as stored;<br>&nbsp;create function income(Employee)-&gt;Integer as stored;&nbsp;<br>&nbsp;create function income(Manager m)-&gt;Integer i&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as income(cast(m as Employee)) + mgrbonus(m);</pre>
    Now, suppose that we need a function that returns the gross incomes
    of all persons in the database, i.e. we use <tt>MANAGER.INCOME-&gt;INTEGER</tt>
    for managers and<tt> EMPLOYEE.INCOME-&gt;INTEGER</tt> for
    non-manager. In Amos II such a function is defined as:
    <pre>&nbsp;create function grossincomes()-&gt;Integer i&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as select income(p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from Employee p; <br>        /* income(p) late bound */</pre>
    Since <tt>income</tt> is overloaded with resolvents <tt>EMPLOYEE.INCOME-&gt;INTEGER</tt>
    and <tt>MANAGER.INCOME-&gt;INTEGER</tt> and both qualify to apply
    to employees, the resolution of <tt>income(p)</tt> will be done at
    run time.&nbsp;
    <p>To avoid the overhead of late binding one may use <a
        href="amos_users_guide.html#casting">casting</a>.&nbsp;<span
        style="font-family: monospace;"></span></p>
    <span style="font-weight: bold;"></span>
    <p>Since the detection of the necessity of dynamic resolution is
      often at compile time, overloading a function name may lead to a
      cascading recompilation of functions defined in terms of that
      function name. This may take some time and the recompilation is
      therefore deferred until a function marked for recompilation is
      called. For a more detailed presentation of the management of late
      bound functions see <a href="#FR95">[FR95]</a>. <br>
    </p>
    <h3><a name="casting"></a>2.4.3 Casting</h3>
    <p></p>
    <p>The type of an expression can be explicitly defined using the <i>casting



      </i>statement:<br>
    </p>
    <pre> casting ::= 'cast'(<a href="#expressions">expr</a> 'as' <a href="#types">type-spec</a>)<br></pre>
    <p>for example<br>
    </p>
    <pre>&nbsp;create function income(Manager m)-&gt;Integer i&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as income(cast(m as Employee)) + mgrbonus(m);</pre>
    <p>By using casting statements one can avoid late binding.<br>
    </p>
    <h3><a name="second-order-functions"></a>2.4.4 Second order
      functions<br>
    </h3>
    <p>Amos II functions are internally represented as objects that can
      be used as any other object, i.e. they are stored in the database
      and can be used in functions and queries, etc. An object
      representing a function is called a <span style="font-style:
        italic;">functional</span>. Second order functions take
      functionals as arguments or results. The system function <span
        style="font-style: italic;">functionnamed</span> retrieves the
      functional <span style="font-style: italic;">fno </span>having a
      given name <span style="font-style: italic;">fn</span>:<br>
    </p>
    <pre>functionnamed(Charstring fn) -&gt; Function fno<br></pre>
    The name <span style="font-style: italic;">fn</span> is not case
    sensitive. NIL is returned if there no function named <span
      style="font-style: italic;">fn</span>. <br>
    <br>
    For example<br>
    <pre>functionnamed("plus");<br>  =&gt; #[OID 155 "PLUS"]<br></pre>
    returns the object representing the <a href="#overloaded-functions">generic</a>
    function <a href="#infix-functions"><span style="font-family:
        monospace;">plus</span></a>, while<br>
    <pre>functionnamed("number.number.plus-&gt;number");<br>  =&gt; #[OID 156 "NUMBER.NUMBER.PLUS-&gt;NUMBER"]<br></pre>
    <p>returns the object representing the <a
        href="#overloaded-functions">resolvent</a> named <span
        style="font-family: monospace;">NUMBER.NUMBER.PLUS-&gt;NUMBER</span>.</p>
    <p>Another example of a second order function is the system function
      <br>
    </p>
    <pre>apply(Function fno, Vector argl) -&gt; Bag of Vector</pre>
    <p>It calls the functional <span style="font-style: italic;">fno </span>with




      <span style="font-style: italic;">argl </span>as argument list.
      The result tuples are returned as a bag of vectors, for example:<br>
    </p>
    <pre>apply(functionnamed("number.number.plus-&gt;number"),{1,3.4});<br>&nbsp; =&gt; {4.4}<br></pre>
    <p>Notice how <span style="font-style: italic;">apply </span>represents




      argument lists and result tuples as <a href="#vectors">vectors</a>.
      <br>
    </p>
    <p>When using second order functions one often needs to retrieve a
      functional <span style="font-style: italic;">fno </span>given
      its name and the function <span style="font-style: italic;">functionnamed




      </span>provides one way to achieve this. However, a better way is
      often to use <span style="font-style: italic;">functional
        constants</span> with syntax:<br>
    </p>
    <pre><a name="functional-constant"></a>functional-constant ::= '#' string-constant<br></pre>
    <p>for example<br>
    </p>
    <pre>#'mod';<br></pre>
    <p>A functional constant is translated into the functional with the
      name uniquely specified by the string constant. For example, the
      following expression<br>
    </p>
    <pre>apply(#'mod',{4,3});<br>&nbsp; =&gt; {1}<br></pre>
    <p><span style="font-weight: bold;">Notice</span> that an error is
      raised if the function name specified in the functional constant
      is not uniquely identifying the functional. This happens if it is
      the <a href="#overloaded-functions">generic</a> name of an
      overloaded function. For example, the functional constant <span
        style="font-family: monospace;">#'plus' </span>is illegal,
      since <a href="#infix-functions"><span style="font-family:
          monospace;">plus</span></a><span style="font-style: italic;">
      </span>is overloaded. For overloaded functions the name of a
      resolvent has to be used instead, for example:<br>
    </p>
    <pre>apply(#'plus',{2,3.5});<br></pre>
    generates an error, while<br>
    <pre>apply(#'number.number.plus-&gt;number', {2,3.5});<br> =&gt; {5.5}<br></pre>
    and<br>
    <pre>apply(functionnamed("plus"),{2,3.5});<br> =&gt; {5.5}<br></pre>
    The last call using <span style="font-family: monospace;">functionnamed</span>
    will be somewhat slower than using <span style="font-family:
      monospace;">#'number.number.plus-&gt;number'</span> since late
    binding is used and the system will determine dynamically which
    resolvent of <a href="#infix-functions"><span style="font-family:
        monospace;">plus</span></a> to apply. <br>
    <h3><a name="transitive-closures"></a>2.4.5 Transitive closures<br>
    </h3>
    <p>The transitive closure functions <span style="font-style:
        italic;">tclose</span> is a <a href="#second-order-functions">second



        order</a> function to explore graphs where the edges are
      expressed by a <span style="font-style: italic;">transition
        function</span> specified by argument <span style="font-style:
        italic;">fno</span>:</p>
    <pre>&nbsp;&nbsp; tclose(Function fno, Object o) -&gt; Bag of Object</pre>
    <p><span style="font-style: italic;">tclose</span> applies the
      transition function <span style="font-style: italic;">fno(o)</span>,
      then <span style="font-style: italic;">fno(fno(o))</span>, then <span
        style="font-style: italic;">fno(fno(fno(o)))</span>, etc until <span
        style="font-style: italic;">fno </span>returns&nbsp; no new
      result. Because of the <a href="#daplex-semantics">Daplex
        semantics</a>, if the transition function <span
        style="font-style: italic;">fno </span>returns a bag of values
      for some argument <span style="font-style: italic;">o</span>, the
      successive applications of<span style="font-style: italic;"> fno </span>will
be
applied
on
each
element
of
the
result
bag.
The
result
types
of
a
transition
function
must
either
be
the
same




      as the argument types or a bag of the argument types. Such a
      function that has the same arguments and (bag of) result types is
      called a <span style="font-style: italic;">closed function</span>.<br>
    </p>
    <p>For example, assume the following definition of a graph defined
      by the transition function <span style="font-style: italic;">arcsto</span>:<br>
    </p>
    <pre>  create function arcsto(Integer node)-&gt; Bag of Integer n as stored;<br>  <a href="#updates">set</a> arcsto(1) = <a href="#collection-syntax">bag</a>(2,3);<br>  set arcsto(2) = bag(4,5);<br>  set arcsto(5) = bag(1);<br></pre>
    <p>The following query traverses the graph starting in node 1:<br>
    </p>
    <pre>Amos 5&gt; tclose(<a href="#functional-constant">#'arcsto'</a>, 1);<br>  1<br>  3<br>  2<br>  5<br>  4<br></pre>
    <p>In general the function <span style="font-style: italic;">tclose</span>
      traverses a graph where the edges (arcs) are defined by the
      transition function. The vertices (nodes) are defined by the
      arguments and results of calls to the transition function <span
        style="font-style: italic;">fno</span>, <span
        style="font-style: italic;"></span><span style="font-style:
        italic;"></span>i.e. a call to the transition function <span
        style="font-style: italic;">fno</span> defines the neighbors of
      a node in the graph. The graph may contain loops and <span
        style="font-style: italic;">tclose</span> will remember what
      vertices it has visited earlier and stop further traversals for
      vertices already visited.<br>
    </p>
    <p>You can also query the inverse of <span style="font-style:
        italic;">tclose</span>, i.e. from which nodes <span
        style="font-style: italic;">f </span>can be reached, by the
      query:</p>
    <pre>Amos 6&gt; select f from Integer f where 1 in tclose(<a href="#functional-constant">#'arcsto'</a>,f);<br>  1<br>  5<br>  2<br></pre>
    <p>If you know that the graph to traverse is a tree or a directed
      acyclic graph (DAG) you can instead use the faster function <br>
    </p>
    <pre>&nbsp;&nbsp; traverse(Function fno, Object o) -&gt; Bag of Object<br></pre>
    <p>The children in the tree to traverse is defined by the transition
      function fno. The tree is traversed in post-order. Leaf nodes in
      the tree are nodes for which <span style="font-style: italic;">fno</span>
      returns nothing. The function <span style="font-style: italic;">traverse</span>
      will not terminate if the graph is circular. Nodes are visited
      more than once for acyclic graphs having common subtrees. <br>
    </p>
    <p>A transition function may have extra arguments and results, as
      long as it is closed. This allows to pass extra parameters to a
      transitive closure computation. For example, to compute not only
      the transitive closure, but also the distance from the root of
      each visited graph node, specify the following transition
      function:<br>
    </p>
    <pre>create function arcstod(Integer node, Integer d) -&gt; Bag of (Integer,Integer)<br>&nbsp; as select arcsto(node),1+d;<br></pre>
    <p>and call<br>
    </p>
    <pre>tclose(<a href="#functional-constant">#'arcstod'</a>,1,0);<br></pre>
    <p>which will return<br>
    </p>
    <pre>(1,0)<br>(3,1)<br>(2,1)<br>(5,2)<br>(4,2)</pre>
    Notice that only the first argument and result in the transition
    function define graph vertices, while the remaining arguments and
    results are extra parameters for passing information through the
    traversal, as with <span style="font-style: italic;">arcstod</span>.
    There may be no more than three extra parameters in a transition
    function.
    <h3><a name="abstract-functions"></a><span style="font-weight:
        bold;"></span>2.4.6 Abstract functions</h3>
    <p>Sometimes there is a need to have a function defined for subtypes
      of a common supertype, but the function should never be used for
      the supertype itself. For example, one may have a common supertype
      <span style="font-family: monospace;">Dog</span> with two subtypes
      <span style="font-family: monospace;">Beagle</span> and <span
        style="font-family: monospace;">Poodle</span>. One would like to
      have the function <span style="font-family: monospace;">bark</span>
      defined for different kinds of dogs, but not for dogs in general.
      In this case one defines the <span style="font-family:
        monospace;">bark</span> function for type <span
        style="font-family: monospace;">Dog</span> as an <span
        style="font-style: italic;">abstract function</span>, for
      example::<br>
    </p>
    <pre>create type Dog;<br>create function name(Dog)-&gt;Charstring as stored;<br>create type Beagle under Dog;<br>create type Poodle under Dog;<br>create function bark(Dog d) -&gt; Charstring as foreign 'abstract-function';<br>create function bark(Beagle d) -&gt; charstring;<br>create function bark(Poodle d) -&gt; charstring;<br>create Poodle(name,bark) instances ('Fido','yip yip');<br>create Beagle(name,bark) instances ('Snoopy','arf arf');<br></pre>
    <p>Now you can use <span style="font-family: monospace;">bark</span>
      as a function over dogs in general, but only if the object is a
      subtype of <span style="font-family: monospace;">Dog</span>:<br>
    </p>
    <pre>Amos 15&gt; select bark(d) from dog d;<br>"arf arf"<br>"yip yip"<br></pre>
    <p>An abstract function is defined by: <br>
    </p>
    <pre>create function foo(...)-&gt;... as foreign 'abstract-function'.</pre>
    <p>This actually defines it as a&nbsp; <a href="#foreign-functions">foreign




        function</a> which <a href="#simple-foreign">implementation</a>
      <span style="font-family: monospace;">is named 'abstract-function'</span>.
      If an abstract function is called it gives an informative error
      message. For example,&nbsp; if one tries to call <span
        style="font-family: monospace;">bark</span> for an object of
      type <span style="font-family: monospace;">Dog</span>, the
      following error message is printed:<br>
    </p>
    <pre>Amos 16&gt; create Dog instances :buggy;<br>NIL<br>Amos 17&gt; bark(:buggy);<br>BARK(DOG)-&gt;CHARSTRING<br>  is an abstract function requiring a more specific argument signature than<br>  (DOG) for arguments<br>  (#[OID 1009])<br> </pre>
    <h2><a name="updates"></a>2.5 Updates </h2>
    Information stored in Amos II represent mappings between function
    arguments and results. These mappings are either defined at object
    creation time (<a href="#create-object">Objects</a>), or altered by
    one of the function update statements 'set', 'add', or 'remove'.
    The&nbsp; <a href="#function-extent">extent</a>&nbsp; of a function
    is the bag of tuples mapping its arguments to corresponding results.
    Updating a stored function means updating its extent.
    <p>Syntax: </p>
    <pre>update-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; update-op update-item [<a href="#select-statement">from-clause</a>] [<a href="#where-clause">where-clause</a>]&nbsp;<br><br>update-op ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'set' | 'add' | 'remove'&nbsp;<br><br>update-item ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#function-name">function-name</a> '(' <a href="#expressions">expr-commalist</a> ')' '=' <a href="#expressions">expr</a></pre>
    <br>
    For example, assume we have defined the following functions:<br>
    <pre><span style="font-family: monospace;">&nbsp; create function name(Person) -&gt; Charstring as stored;<br>  create function hobbies(Person) -&gt; Bag of Charstring as stored;</span></pre>
    Furthermore, assume we have created two objects of type <span
      style="font-style: italic;">Person</span> bound to the environment
    variables <span style="font-style: italic;">:sam</span> and <span
      style="font-style: italic;">:eve</span>:<br>
    <pre><span style="font-family: monospace;">&nbsp; create Person instances :sam, :eve;</span></pre>
    The <span style="font-style: italic;">set </span>statement sets
    the value of an updatable function given the arguments. <br>
    For example, to set the names of the two persons, do:<br>
    <pre><span style="font-family: monospace;">&nbsp; set name(:sam) = "Sam";<br>  set name(:eve)= "Eve";</span></pre>
    <span style="font-family: monospace;"> </span>To populate a bag
    valued function you can use <a href="#collection-syntax">bag
      expressions:</a><br>
    <pre>set hobbies(:eve) = bag("Camping","Diving");</pre>
    The <span style="font-style: italic;">add </span>statement adds
    result elements to bag valued functions.<br>
    For example, to make Sam have the hobbies sailing and fishing, do:<br>
    <pre><span style="font-family: monospace;">&nbsp; add hobbies(:sam) = "Sailing";<br>  add hobbies(:sam) = "Fishing";</span></pre>
    The <span style="font-style: italic;">remove </span>statement
    removes the specified tuple(s) from the result of an updatable
    function returning a bag for given arguments, for example:<br>
    <pre><span style="font-family: monospace;">&nbsp; remove hobbies(:sam) = "Fishing";</span></pre>
    Several object properties can be assigned by specifying the <span
      style="font-style: italic;">set</span> or <span
      style="font-style: italic;">add</span> statement by a query.<br>
    For example, to make Eve have the same hobbies as Sam except
    sailing, do:<br>
    <pre><span style="font-family: monospace;">&nbsp; set hobbies(:eve) = h<br>  from Charstring h<br>  where h in hobbies(:sam) and<br>        h != "Sailing";</span></pre>
    <span style="font-family: monospace;"></span><span
      style="font-family: monospace;"></span>A boolean function can be
    set to either <span style="font-style: italic;">true</span> or <span
      style="font-style: italic;">false</span>. <br>
    <pre><span style="font-family: monospace;">&nbsp; create function married(Person,Person)-&gt;Boolean as stored;<br>  set married(:sam,:eve) = true;</span></pre>
    Setting the value of a boolean function to <span style="font-style:
      italic;">false</span> means that the truth value is removed from
    the extent of the function, for example:<br>
    To divorce Sam and Eve you can do either of the following:<br>
    <pre><span style="font-family: monospace;">&nbsp; set married(:sam,:eve)=false;<br></span></pre>
    &nbsp;or
    <pre><span style="font-family: monospace;">&nbsp; remove married(:sam) = :eve;</span></pre>
    <br>
    <a name="one-of"></a>A variable can be assigned to a bag returned by
    some function by using the assigment statement. For example:<span
      style="font-family: monospace;"><br>
    </span>
    <pre><span style="font-family: monospace;">  set :h = hobbies(:sam);</span></pre>
    will assign <span style="font-style: italic;">:h</span> to a bag of
    Sam's hobbies since the result type of function <span
      style="font-style: italic;">hobbies</span> is 'Bag of Charstring'.
    The elements can be extracted with <span style="font-style:
      italic;">in</span>:<br>
    <br>
    <span style="font-family: monospace;">&nbsp; in(:h);</span><br>
    <br>
    The multiple assignment statement assigns several variables to the
    result of a tuple valued query, for example:<br>
    <pre>  set (:mother,:father) = parents2(:eve);<br></pre>
    The statement<br>
    <pre><span style="font-family: monospace;">&nbsp; set hobbies(:eve) = hobbies(:sam);</span></pre>
    will update Eve's all hobbies to be the same a Sam's hobbies.<br>
    <br>
    Not every function is updatable. Amos II defines a function to be
    updatable if it is a stored function, or if it is derived from a
    single updatable function without a join including all arguments. In
    particular inverses to stored functions are updatable. For example,
    the following function is updatable:<br>
    <pre><span style="font-family: monospace;">&nbsp; create function marriedto(Person p) -&gt; Person q<br>  as select q where married(p,q);</span></pre>
    The user can declare <a
      href="file:///C:/AmosNT/doc/amos_users_guide.html#user-update-functions">explicit




      update rules</a> for derived functions making also non-updatable
    functions updatable.<br>
    <br>
    <a name="cardinality-constraints"></a>
    <h3><a name="2.5.1_Cardinality_constraints"></a> 2.5.1 Cardinality
      constraints</h3>
    A <i>cardinality constraint</i> is a system maintained restriction
    on the number of allowed occurrences in the database of an argument
    or result of a <a
      href="file:///C:/AmosNT/doc/amos_users_guide.html#stored-function">stored




      function</a>. For example, a cardinality constraint can be that
    there can be at most one salary and a unique name per person, while
    a person may have any number of children. The cardinality
    constraints are normally specified by the result part of a stored
    function's signature.<br>
    <br>
    For example, the following restricts each person to have one salary
    while many children are allowed:<br>
    <br>
    <span style="font-family: monospace;">&nbsp;&nbsp; create function
      salary(Person p) -&gt; Charstring nm as stored;<br>
      &nbsp;&nbsp; create function children(Person p) -&gt; Bag of
      Person c as stored;<br>
    </span><br>
    The system will restrict database updates so that the cardinality
    constraints are not violated.&nbsp; For the function <span
      style="font-family: monospace;">salary</span> an error is raised
    if one tries to make a person have two salaries when updating it
    with the <a href="#updates">add statement</a>, while there is no
    such restriction on <span style="font-family: monospace;">children</span>.
    If the cardinality constraint is violated by a database update the
    following error message is printed:<br>
    <br>
    <span style="font-family: monospace;">&nbsp;&nbsp; Update would
      violate upper object participation (updating function ...)</span><br>
    <br>
    In general one can maintain four kinds of cardinality constraints
    for a function modeling a relationship between types, <span
      style="font-style: italic;">many-one, many-many, one-one,</span>
    and <span style="font-style: italic;">one-many</span>:<br>
    <ul>
      <li><span style="font-style: italic;">many-one</span> is the
        default when defining a stored function as in <span
          style="font-family: monospace;">salary</span>.<br>
        <br>
      </li>
      <li><span style="font-style: italic;">many-many</span> is
        specified by prefixing the result type specification with 'Bag
        of' as in <span style="font-family: monospace;">children</span>.<br>
        <br>
      </li>
      <li><span style="font-style: italic;">one-one</span> is specified
        by suffixing a result variable with '<span style="font-family:
          monospace;">key</span>'<br>
        For example:<br>
        <span style="font-family: monospace;">&nbsp;&nbsp; create
          function name(Person p) -&gt; Charstring nm key as stored;<br>
        </span>will guarantee that a person's name is unique.<br>
        <br>
      </li>
      <li><span style="font-style: italic;">one-many</span> is normally
        represented by the inverse function. For example, suppose we
        want to represent the one-many relationship between types <span
          style="font-family: monospace;">Department</span> and <span
          style="font-family: monospace;">Employee </span>that there
        are many employees for a given department but only one
        department for a given employee. The recommended way is to
        define the function:<br>
        <br>
        <span style="font-family: monospace;">&nbsp; create function
          department(Employee e) -&gt; Department d as stored;<br>
        </span><br>
        The inverse function can then be defined as a derived function:<br>
        <br>
        <span style="font-family: monospace;">&nbsp; create function
          employees(Department d) -&gt; Bag of Employee e</span><br
          style="font-family: monospace;">
        <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; as
          select e where department(e) = d;</span><br>
        <br>
        Inverse functions are <a href="#updates">updatable</a>.<br>
      </li>
    </ul>
    Any variable in a stored function can be specified as <span
      style="font-style: italic;">key</span>, which will restrict the
    updates the stored functions to maintain key uniqueness for the
    argument or result of the stored function. For example, the
    cardinality constraints on the following function <span
      style="font-family: monospace;">distance </span>prohibits more
    than one distance between two cities:<br>
    <span style="font-family: monospace;">&nbsp; <br>
      &nbsp; create function distance(City x key, City y&nbsp; key)
      -&gt;&nbsp; Integer d as stored;</span><br>
    <br>
    Cardinality constraints can also be specified for <a
      href="file:///C:/AmosNT/doc/amos_users_guide.html#foreign-functions">foreign




      functions</a>. These are important for optimizing queries
    involving foreign functions. However, it is up to the foreign
    function implementor to guarantee that specified cardinality
    constraints hold. <br>
    <br>
    <br>
    <a name="add-type"></a><br>
    <h3> 2.5.2 Dynamically changing object types</h3>
    The <tt>add-type-stmt</tt> changes the type of one or more objects
    to the specified type.
    <p>Syntax: </p>
    <pre>add-type-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'add type' <a href="#type-name">type-name</a> ['(' [<a href="#function-definitions">generic-function-name-commalist</a>] ')']&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'to' <a href="#variables">variable-commalist</a></pre>
    The updated objects may be assigned initial values for all the
    specified property functions in the same manner as in the <a
      href="#create-object">create object statement</a>.
    <p>The <tt>remove-type-stmt</tt> makes one or more objects no
      longer belong to the specified type.<br>
    </p>
    <p>Syntax: </p>
    <pre>remove-type-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'remove type' <a href="#type-name">type-name</a> 'from' <a href="#variables">variable-commalist</a></pre>
    Referential integrity is maintained so that all references to the
    objects as instances of the specified type cease to exist.&nbsp; If
    all user defined types have been removed, the object will still be
    member of type <tt>Userobject</tt>.<br>
    <a name="user-update-functions"></a><br>
    <h3> 2.5.3 User update procedures</h3>
    It is possible to register user defined<i> user update procedures</i>
    for any function. The user update procedures are <a
      href="#procedures">procedural functions</a> that are transparently
    invoked when update statements are executed for the function.
    <p>&nbsp;&nbsp;&nbsp; <code>set_addfunction(Function f, Function
        up)-&gt;Boolean<br>
        &nbsp; set_remfunction(Function f, Function up)-&gt;Boolean<br>
        &nbsp; set_setfunction(Function f, Function up)-&gt;Boolean<br>
      </code><br>
      The function <tt>f</tt> is the function for which we wish to
      declare a user update function and <tt>up</tt> is the actual
      update procedure. The arguments of a user update procedures is the
      concatenation of argument and result tuples of <span
        style="font-family: monospace;">f</span>. For example, assume we
      have a function<br>
    </p>
    <p><span style="font-family: monospace;">&nbsp; create function
        netincome(Employee e) -&gt; Number <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as
        income(e)-taxes(e);</span><br>
    </p>
    <p>Then we can define the following user update procedure:<br>
    </p>
    <p><span style="font-family: monospace;">&nbsp; create function
        set_netincome(Employee e, Number i)-&gt; Boolean<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as begin<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        set taxes(e)= i*taxes(e)/income(e) + taxes(e);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        set income(e) = i*(1-taxes(e))/income(e) + income(e);<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        end;<br>
      </span></p>
    <p>The following declaration makes <span style="font-family:
        monospace;">netincome </span>updatable with the <span
        style="font-family: monospace;">set</span> statement:<br>
    </p>
    <p><span style="font-family: monospace;">&nbsp; set_setfunction(<a
          href="#functional-constant">#'employee.netincome-&gt;number'</a>,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        #'employee.number-&gt;boolean');<br>
      </span></p>
    <p>Now one can update <span style="font-family: monospace;">netincome




      </span>with, e.g.:<br>
    </p>
    <p><span style="font-family: monospace;">&nbsp; set
        netincome(p)=32000 from Person p where name(p)="Tore";</span><br>
      <br>
    </p>
    <p><a name="dynamic-updates"></a> </p>
    <h3> 2.5.4 Dynamic updates</h3>
    Sometimes it is necessary to be able to create objects whose types
    are not known until runtime. Similarly one may wish to update
    functions without knowing the name of the function until runtime.
    For this there are the following system procedural system functions:
    <p> <code>createobject(Type t)-&gt;Object<br>
        createobject(Charstring tpe)-&gt;Object<br>
        deleteobject(Object o)-&gt;Boolean<br>
        addfunction(Function f, Vector argl, Vector resl)-&gt;Boolean<br>
        remfunction(Function f, Vector argl, Vector resl)-&gt;Boolean<br>
        setfunction(Function f, Vector argl, Vector resl)-&gt;Boolean<br>
      </code><br>
      <tt>createobject</tt> creates a surrogate object of the type
      specified by its argument. </p>
    <p> <tt>deleteobject</tt> deletes a surrogate object. </p>
    <p> The procedural system functions <tt>setfunction</tt>, <tt>addfunction</tt>,
      or <tt>remfunction</tt> update a function given an argument list
      and a result tuple as <a href="#vector">vectors</a>. They return
      <tt>TRUE</tt> if the update succeeded.<br>
    </p>
    <p>To delete all rows in a stored function <span style="font-style:
        italic;">fn</span>, use<br>
    </p>
    <pre>dropfunction(Function fn, Integer permanent)-&gt;Function</pre>
    <p>If the parameter <span style="font-style: italic;">permanent</span>
      is one the deletion cannot be rolled back. <br>
    </p>
    <h2><a name="collections"></a>2.6 Collections<br>
    </h2>
    Amos II supports three kinds of collections: bags, vectors, and
    key-value collections:<br>
    <ul>
      <li>A <span style="font-style: italic;">bag </span>is a set
        where duplicates are allowed. </li>
      <li>A <span style="font-style: italic;">vector </span>is an
        ordered sequence of objects.</li>
      <li>A <span style="font-style: italic;">record</span> is an
        associative array of key-value pairs.<br>
      </li>
    </ul>
    The result of a <a href="#select-statement">query</a> is a bag of
    tuples of objects. The tuples themselves are not objects but must be
    retrieved using the <a href="#tuple-expr">tuple-expr</a> notation.
    This section first introduces aggregate functions, which are
    functions computing aggregated values over bags, such as sums and
    averages. Then the general behavior of the built in collection types
    <span style="font-style: italic;">Bag </span>and <span
      style="font-style: italic;">Vector </span>are described.<br>
    <h3><a name="subqueries"></a>2.6.1 Subqueries and aggregate
      functions</h3>
    <span style="font-style: italic;">Aggregate functions</span> are
    functions where one or several arguments are declared as bags:
    <pre>&nbsp;&nbsp; Bag of <span style="font-style: italic;">type</span> x</pre>
    The following system aggregate functions are defined:
    <pre>&nbsp;&nbsp; sum(Bag of Number x) -&gt; Number&nbsp;<br>&nbsp;&nbsp; count(Bag of Object x) -&gt; Integer<br>&nbsp;&nbsp; avg(Bag of Number x) -&gt; Real<br>&nbsp;&nbsp; stdev(Bag of Number x) -&gt; Real<br>&nbsp;&nbsp; maxagg(Bag of Object x) -&gt; Object<br>&nbsp;&nbsp; minagg(Bag of Object x) -&gt; Object<br>&nbsp;&nbsp; some(Bag of Object x) -&gt; Boolean<br>&nbsp;&nbsp; notany(Bag of Object x) -&gt; Boolean</pre>
    For example, <tt>sum</tt> must be applied only to bags of numbers.
    <p>Now consider the query:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; select name(friends(p)) <br>  from Person p <br>  where name(p)= "Bill";</span><br></pre>
    <p>The function <span style="font-style: italic;">friends </span>returns




      several (a bag of) persons on which the function <span
        style="font-style: italic;">name</span> is applied. The normal
      semantics in Amos II is that when a function (e.g. <span
        style="font-style: italic;">name</span>) is applied on a bag
      valued function&nbsp; (e.g. <span style="font-style: italic;">friends</span>)
      it will be applied <span style="font-style: italic;">on each
        element</span> of the returned bag.&nbsp; In the example a bag
      of the names of the persons named Bill is returned. <span
        style="text-decoration: underline;"></span></p>
    <p><span style="text-decoration: underline;"></span>Aggregate
      functions work differently. They are applied <span
        style="font-style: italic;">on the entire</span> bag. For
      example:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; count(friends(:p));</span></pre>
    <p>In this case <span style="font-style: italic;">count </span>is
      applied on the entire bag of all friends of <span
        style="font-style: italic;">:p</span>. This <span
        style="font-style: italic;">closed bag</span> is specified by
      declaring the type of an argument of an aggregate function with
      'Bag of''. The function <span style="font-style: italic;">count </span>thus




      has the signature:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; count(Bag of Object) -&gt; Integer</span></pre>
    <p></p>
    <p>Aggregate functions can be applied on subqueries, for example:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; count(select p from Person p);</span></pre>
    <p></p>
    <p>The following two queries return the same values:<span
        style="font-family: monospace;"></span><br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; count(select friends(:p));<br></span><span style="font-family: monospace;">  count(friends(:p));</span><br></pre>
    <p></p>
    <p>Local variables in queries may be declared as bags that can be
      used as arguments to aggregate functions. <br>
      For example, the function <span style="font-style: italic;">totalincomes</span>
      computes the sum of all incomes: </p>
    <pre>create function totalincomes()-&gt;Integer<br>  as sum(select income(p) from Person P);<br></pre>
    or
    <pre>create function totalincomes()-&gt;Integer<br>  as select sum(b) <br>     from Bag of Integer b<br>     where b = (select income(p) <br>                 from Person p);<br></pre>
    <b> Notice</b> that stored functions cannot have arguments declared
    'Bag of''.
    <h3><a name="bag-semantics"></a>2.6.2 Bags<br>
    </h3>
    <p>When a stored function is defined the default is that it can
      return only a single value. For example:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; create function friends(Person p) -&gt; Person f as stored;</span></pre>
    <p></p>
    <p>In this case there is a <a href="#cardinality-constraints">cardinality




        constraint</a> that says that a given person <span
        style="font-style: italic;">p</span> can have only a single
      friend <span style="font-style: italic;">f</span>. This
      cardinality constraint is removed by instead defining:<br>
    </p>
    <pre><span style="font-family: monospace;">&nbsp; create function friends(Person p) -&gt; Bag of Person f as stored;</span></pre>
    The update commands set,&nbsp; <a href="#updates"><span
        style="font-family: monospace;">add</span></a>, and <span
      style="font-family: monospace;"><a href="#updates">remove</a> </span>can




    be used for updating such bag valued functions.<br>
    <br>
    For <a href="#derived-function">derived functions</a> the result
    can potentially always be a bag since the result of the <span
      style="font-style: italic;">select</span> statement is a bag. For
    example:<br>
    <pre><span style="font-family: monospace;">create function friendsof(Charstring pn)-&gt; Bag of Charstring fn<br></span><span style="font-family: monospace;">&nbsp; as select name(friends(p)) </span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;<br>     from Person p</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;<br>     where name(p)=pn;</span><br></pre>
    You can set a variable to the bag representing the result from a
    query (i.e. a select statement), for example:<br>
    <pre><span style="font-family: monospace;">&nbsp; set :fnb = friendsof("Bill");</span></pre>
    Since the result type of <span style="font-style: italic;">friendsof</span>
    is 'Bag of Charstring', in this case the variable <span
      style="font-style: italic;">:fnb</span> is bound to the <span
      style="font-style: italic;">bag</span> of friends of Bill. If the
    result type had been just 'Charstring', instead <span
      style="font-style: italic;">:fnb</span> would have been assigned
    the first element in the bag of Bill's friends.<br>
    <br>
    You can extract the elements from the bag with the <span
      style="font-style: italic;">in</span>&nbsp; function or infix
    operator:<br>
    <pre><span style="font-family: monospace;">&nbsp; in(:fnb);<br>  select fn from Charstring fn where fn in :fnb;<br></span></pre>
    <span style="font-weight: bold;">Notice</span> that, unlike most
    programming languages, bags are <span style="font-style: italic;">not




    </span>evaluated when they are assigned. It is up to the query
    optimizer to compute the values of a bag when so needed. <br>
    <br>
    Query variables can also be bound to bags, e.g<span
      style="font-family: monospace;">.:</span><br>
    <pre><span style="font-family: monospace;">&nbsp; select sum(b),count(b) <br>  from Bag of Integer b<br>  where b = (select income(p) <br>             from Person p);</span></pre>
    <span style="font-family: monospace;"></span> The elements of a bag
    can be extracted with the <span style="font-style: italic;">in</span>
    operator, e.g.:<br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">select t/i<br>
      &nbsp; from Number i, Number t, Bag of (Number, Number) b <br>
      &nbsp; where (i, t) in </span><span style="font-family:
      monospace;">b and <br>
      &nbsp;</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      b = (select income(p), taxes(p) </span><br style="font-family:
      monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      from Person p);<br>
    </span><br>
    <span style="font-weight: bold;">Notice</span> that in this case the
    preferred much more elegant <span style="font-style: italic;">flat</span>
    formulation of the query is:<br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">select
      income(p)/taxes(p)<br>
      &nbsp; from Person p;<br>
    </span><br>
    Avoid using the <span style="font-style: italic;">in</span>
    operator if a more elegant (and efficient) flat query formulation
    can be made!<br>
    <br>
    Sometimes it is more convenient to use the function <span
      style="font-style: italic;">in()</span> that extracts the elements
    from closed bags, for example:<span style="font-family: monospace;"></span><br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">select
      in(b)<br>
      &nbsp; from Bag of Number b <br>
      &nbsp; where</span><span style="font-family: monospace;"></span><span
      style="font-family: monospace;"> b = (select income(p) </span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




      from Person p);<br>
    </span><br>
    <span style="font-weight: bold;">Notice</span> that the preferred
    elegant and efficient flat formulation of the above query is:<br>
    &nbsp;&nbsp;&nbsp; <span style="font-family: monospace;">select </span><span
      style="font-family: monospace;">income(p) </span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; from Person p;</span><br>
    <br>
    If you make the query<br>
    <span style="font-family: monospace;">&nbsp; count(friends(:p));</span><br>
    the system uses a rule that non bag arguments are converted
    (coerced) into a closed bags if an argument (e.g. of the aggregate
    function <span style="font-style: italic;">count</span>) so
    requires. <br>
    <br>
    The query could also have been formulated as<br>
    &nbsp;&nbsp; <span style="font-family: monospace;">count(select
      friends(:p));</span>
    <pre><span style="font-family: monospace;"></span></pre>
    <span style="font-family: monospace;"></span><br>
    Sometimes it may be necessary to materialize a bag explicitly, which
    is done by the function:<br>
    <pre><span style="font-family: monospace;">&nbsp; materialize(Bag of <span style="font-style: italic;">T</span> b) -&gt; <span style="font-style: italic;">T</span> m</span></pre>
    where <span style="font-style: italic;">T</span> can be any type.
    The function <span style="font-style: italic;">materialize</span>
    extracts all the elements from bag b and stores them in the <span
      style="font-style: italic;">materialized</span> bag <span
      style="font-style: italic;">m</span>. Notice the differences
    between these assignments:<br>
    <pre><span style="font-family: monospace;">set :f = friendsof("Bill");            /* assigns :f to a bag of Bill's friends. */  <br><br>set :mb = materialize(friendsof("Bill")); /* Assigns :mb to a materialized bag of Bill's friends */<br></span></pre>
    <br>
    To compare that two bags are equal use:<br>
    <pre>  bequal(Bag x, Bag y) -&gt; Boolean<br></pre>
    <span style="font-weight: bold;">Notice</span> that <span
      style="font-style: italic;">bequal</span> materializes its
    arguments before doing the equality computation.<br>
    <pre><span style="font-family: monospace;"></span><span style="font-family: monospace;"></span></pre>
    <h3><a name="vectors"></a>2.6.3 Vectors</h3>
    Vectors represent sequences of objects of any type. <br>
    <br>
    Vectors can be constructed in queries and updates using the <a
      href="#collection-syntax">vector-expr</a> notation. <br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; set :a = {1,2,3};</span><br>
    sets variable <span style="font-style: italic;">:a</span> to a
    vector value.<br>
    <br>
    The following query forms a bag of vectors holding the persons named
    Bill together with their ages.<br>
    <span style="font-family: monospace;">&nbsp; select {p,age(p)} from
      Person p where name(p)="Bill";</span><br>
    <br>
    The previous query is different from the query<br>
    <span style="font-family: monospace;">&nbsp; select p, age(p) from
      Person p where name(p)="Bill"</span><br>
    that returns bag of tuples. <br>
    <br>
    Vectors can be queried by converting them to bags using the <span
      style="font-style: italic;">in </span>operator.<br>
    For example:<br>
    <span style="font-family: monospace;">select x from Number x where x
      &gt; 1 and x in :a;</span><br>
    returns the bag elements:<br style="font-family: monospace;">
    <span style="font-family: monospace;">2</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">3</span><br>
    <br>
    <span style="font-weight: bold;">Notice</span> that the order of the
    elements of a bag is <span style="font-weight: bold;">not</span>
    predetermined and you cannot assume that selecting elements from a
    vector is in the vector's element order. In general the order of the
    elements of a bag is undefined and the query optimizer has the
    freedom to return a bag in any order if that speeds up query
    execution.<br>
    <br>
    Vector elements can also be accessed using the <span
      style="font-style: italic;">vector-indexing</span> notation:<br>
    <br>
    <span style="font-family: monospace;"><a name="vector-index"></a>&nbsp;
vector-indexing




      ::= simple-expr '[' expr-commalist ']'</span><br>
    <br>
    The first element in a vector has index 0 etc.<br>
    For example: <span style="font-family: monospace;"><br>
      &nbsp; :a[0]+:a[1];<br>
    </span>returns<br>
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; 3</span><br>
    <br>
    Index variables can be unbound in queries to specify iteration over
    all possibles index positions of a vector. <br>
    For example:<br>
    <span style="font-family: monospace;">select i, :a[i] from Integer
      i, where i &gt;= 1;</span><br>
    returns the bag of tuples:<br>
    <span style="font-family: monospace;">(1,2)</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">(2,3)<br>
      <br>
    </span>The following function converts a vector to a bag:<br>
    <pre><span style="font-family: monospace;">&nbsp; create function vectorBag(Vector v) -&gt; Bag of Object<br>  as select v[i] <br>     from Integer i;</span></pre>
    For example:<br>
    <pre><span style="font-family: monospace;">&nbsp; vectorbag({1,2,3});<br></span></pre>
    returns the bag<br>
    <span style="font-family: monospace;">1</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">2</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">3</span><br
      style="font-family: monospace;">
    <br>
    <a name="vselect"></a>The aggregate function <span
      style="font-style: italic;">vectorof</span> converts a bag to a
    vector:<br>
    <br>
    <span style="font-family: monospace;">&nbsp; vectorof(Bag of Object
      b) -&gt; Vector v</span><br>
    <span style="font-family: monospace;"><br>
    </span>For example:<br>
    <span style="font-family: monospace;">&nbsp; vectorof(select <a
        href="#iota">iota</a>(1,10));</span><br>
    or just:<br>
    <span style="font-family: monospace;">&nbsp; vectorof(<a
        href="amos_users_guide.html#iota">iota</a>(1,10));</span><br>
    <br>
    returns the vector<br>
    <span style="font-family: monospace;">&nbsp; {1,2,3,4,5,6,7,8,9,10}</span><span
      style="font-family: monospace;"><br>
      <br>
    </span>The function <span style="font-style: italic;">vectorof</span>&nbsp;
can
be
used
when
the
order
of
the
elements
in
the
produced
vector
is
unimportant.
Notice
again
that
the
order




    of the elements returned by a select expression (bag) is
    undetermined.&nbsp; The order of the elements in a bag depends on
    the operators in the query and is the order that is the most
    efficient to execute the query. <br>
    <br>
    In order to exactly specify the index order when converting a bag to
    a vector, use the system aggregate function:<br>
    <span style="font-family: monospace;">&nbsp; vectorize(Bag vb) -&gt;
      Vector r</span><br>
    The function <span style="font-style: italic;">vectorize</span>
    takes as input <span style="font-style: italic;">vb</span> a <span
      style="font-style: italic;">vector bag</span> of tuples <span
      style="font-style: italic;">(i, o)</span> and forms a vector <span
      style="font-style: italic;">r</span> containing objects <span
      style="font-style: italic;">o</span> in position <span
      style="font-style: italic;">i</span> of the vector bag. <br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; vectorize(select i, i*i
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      from Integer i<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where i in <a href="#iota">iota</a>(0,10));</span><br>
    will form the vector<br>
    <span style="font-family: monospace;">&nbsp;
      {0,1,4,9,16,25,36,49,64,81,100}</span><br>
    <br>
    The function <span style="font-style: italic;">vectorize </span>is
    much slower than <span style="font-style: italic;">vectorof</span>,
    so use <span style="font-style: italic;">vectorize </span>only
    when needed.<br>
    <br>
    The tuples in a vector bag can contain several object elements <span
      style="font-style: italic;">(i, o1,o2,...)</span>, in which case <span
      style="font-style: italic;">vectorize </span>will form vectors of
    vectors.<br>
    <br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; vectorize(select i,
      2*i, 3*i <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      from Integer i <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      where i in <a href="#iota">iota</a>(0,10));</span><br>
    will form the vector<br>
    <span style="font-family: monospace;">&nbsp;
{{0,0},{2,3},{4,6},{6,9},{8,12},{10,15},{12,18},{14,21},{16,24},{18,27},{20,30}}</span><br>
    <br>
    To convert a vector into a vector bag use the system function<br>
    <span style="font-family: monospace;">&nbsp; bagify(Vector v)-&gt;
      Bag of (Integer i, Object o1,...on)</span><br>
    <br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; bagify({2,4,6,8});</span><br>
    yields the bag<br>
    &nbsp;&nbsp; <span style="font-family: monospace;">(0,2)</span><br
      style="font-family: monospace;">
    &nbsp;&nbsp; <span style="font-family: monospace;">(1,4)</span><br
      style="font-family: monospace;">
    &nbsp;&nbsp; <span style="font-family: monospace;">(2,6)</span><br
      style="font-family: monospace;">
    &nbsp;&nbsp; <span style="font-family: monospace;">(3,8)</span><br
      style="font-family: monospace;">
    <br>
    The query:<br>
    <span style="font-family: monospace;">&nbsp; bagify({{1,2},{3,4}});</span><br>
    yields the bag:<br>
    &nbsp;&nbsp; <span style="font-family: monospace;">(0,{1,2})</span><br
      style="font-family: monospace;">
    &nbsp;&nbsp; <span style="font-family: monospace;">(1,{3,4})</span><br>
    <br>
    Notice that the function <span style="font-style: italic;">bagify</span>
    is the inverse of function <span style="font-style: italic;">vectorize</span>.<br>
    <br>
    The function <i>project</i> constructs a new vector by extracting
    from the vector <span style="font-style: italic;">v </span>the
    elements in the positions in <span style="font-style: italic;">pv</span>:<br>
    <span style="font-family: monospace;">&nbsp; project(Vector v,
      Vector of Number pv) -&gt; Vector r</span> <br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; project({10, 20, 30,
      40},{0, 3, 2});<br>
    </span>&nbsp;returns <span style="font-family: monospace;">{10, 40,
      30}</span><br>
    <br>
    The function <span style="font-style: italic;">substv </span>replaces




    <span style="font-style: italic;">x</span> with <span
      style="font-style: italic;">y</span> in vector <span
      style="font-style: italic;">v</span>:<br>
    <span style="font-family: monospace;">&nbsp; substv(Object x, Object
      y, Vector v) -&gt; Vector r</span><br>
    <br>
    The system function <span style="font-style: italic;">dim</span>
    computes the size <span style="font-style: italic;">d</span> of a
    vector <span style="font-style: italic;">v</span>:<br>
    <span style="font-family: monospace;">&nbsp; dim(Vector v) -&gt;
      Integer d</span><br>
    <br>
    The function <span style="font-style: italic;">concat </span>concatenates




    two vectors:<br>
    &nbsp;<span style="font-family: monospace;"> concat(Vector x, Vector
      y) -&gt; Vector r</span><br>
    <h3><a name="records"></a>2.6.4 Key-value associations</h3>
    The collection datatype named <span style="font-style: italic;">Record</span>
    is used for representing dynamic associations between keys and
    values.&nbsp; A record is a dynamic and associative array. Other
    commonly used terms for associative arrays are property lists,
    key-value pairs, or hash links (Java). For example the following
    expression represents a record where the key (property) 'Greeting'
    field has the value 'Hello, I am Tore' and the key 'Email' has the
    value 'Tore.Andersson@it.uu.se':<br>
    <pre>{'Greeting':'Hello, I am Tore','Email':'Tore.Andersson@it.uu.se'}</pre>
    You can store records in Amos II as anoy other datatype, e.g.<br>
    <pre>create function pdata(Person) -&gt; Record as stored;<br>create Person(pdata) instances ({'Greeting':'Hello, I am Tore',<br>                                 'Email':'Tore.Andersson@it.uu.se'});</pre>
    A possible query could be:<br>
    <pre>select r['Greeting'] <br>from Person p, Record r <br>where name(p)='Tore' and pdata(p)=r;</pre>
    Notice that records and Amos II function are similar. The main
    difference is that records are dynamic in the sense that one can
    assign property values without any restrictions, while functions
    must be predefined by the schema. The problem with arbitrary
    properties is that there is no guarantee that users are actually
    being systematic when assigning new properties, while with
    schema-defined functions one gets a systematic naming of the
    properties. The user should be careful to choose the right data
    representation depending on the application.
    <h2><a name="data-mining"></a>2.7 Data mining primitives</h2>
    Amos II Release 14 provides primitives for advanced analysis,
    aggregation, and visualizations of data collections. This is useful
    for data mining applications, e.g. for clustering and identifying
    patterns in data collections. Primitives are provided for analyzing
    both unordered collections (bags) and ordered collections (vectors).
    Primitive functions are provided for <a href="#group-by">grouping </a>the




    result of queries, basic <a href="#vector-numerical">numerical
      vector</a> functions, <a href="#distance-functions">distance</a>
    functions, and&nbsp; <a href="#statistical-functions">statistical</a>
    functions. The results of the analyzes can be visualized by calling
    an external <a href="#plot">data visualization</a> package. <br>
    <h3><a name="top-k"></a>2.7.1 Top-k queries</h3>
    The function <i>topk</i> returns the top <i>k</i> elements in a
    bag:<br>
    <br>
    <tt>&nbsp; topk(Bag b, Integer k) -&gt; (Object rk, Object value)</tt><br>
    <br>
    If the tuples in <tt>b</tt> have only one attribute (the <span
      style="font-style: italic;">rk</span> attribute), the value will
    be <tt>nil</tt>.<br>
    <br>
    For example,<br>
    <tt>topk(<a href="#iota">iota</a>(1, 100), 3);</tt><br>
    returns
    <pre>(98,NIL)<br>(99,NIL)<br>(100,NIL)</pre>
    whereas
    <pre>topk((select i, v[i-1]<br>      from integer i, vector v<br>      where i in <a href="#iota">iota</a>(1, 5)<br>      and v={"", "", "", "fourth", "fifth"}), 3);<br></pre>
    returns<br>
    <pre>(3,"")<br>(4,"fourth")<br>(5,"fifth")</pre>
    Similar to <i>topk</i>, <i>leastk</i> returns the <i>k</i> least
    elements in a bag.<br>
    <tt>&nbsp; leastk(Bag b, Integer k) -&gt; (Object key, Object value)</tt><br>
    <br>
    For example,<br>
    <tt>leastk(<a href="#iota">iota</a>(1, 100), 3);</tt><br>
    <br>
    returns
    <pre>(3,NIL)<br>(2,NIL)<br>(1,NIL)</pre>
    <p> </p>
    <h3><a name="group-by"></a>2.7.2 Grouped aggregation</h3>
    To investigate how related data values form groups of values,
    aggregate functions need to be applied on groups of values for each
    value of some variable. For example, one would like to count how
    many employees there are for each department with the following
    schema:<br>
    <pre>  create type Department;<br>  create function name(Department)-&gt;Charstring as stored;<br> &nbsp;create type Employee;<br>  create function name(Employee)-&gt;Charstring as stored;<br> &nbsp;create function dept(Employee)-&gt;Department as stored;<br>  <br>  create Department(name) instances :d1 ("Toys"), :d2 ("Cloths");<br>  create Employee(name, dept) instances ("Kalle", :d1),("Pelle", :d1),("Oskar",:d2),("Ludolf",:d2),("Anna",:d2);<br></pre>
    The following query returns the different departments in <span
      style="font-style: italic;">dept </span>along with counts of the
    number of employees per department;<br>
    <pre>  groupby((select name(d), e <br>           from Department d, Employee e <br>           where dept(e)=d),<br>          <a href="#functional-constant">#'count'</a>);<br>  =&gt;  ("Toys",2)<br>      ("Cloths",3)<br></pre>
    The groups on which the aggregate function is applied are
    constructed with the <span style="font-style: italic;">group
      forming query</span>:<br>
    <pre>  select name(d), e <br>  from Department d, Employee e <br>  where dept(e)=d;<br>  =&gt; ("Toys",#[OID 1360])<br>     ("Toys",#[OID 1359])<br>     ("Cloths",#[OID 1361])<br>     ("Cloths",#[OID 1362])<br>     ("Cloths",#[OID 1363])<br></pre>
    The <a href="amos_users_guide.html#second-order-functions">second
      order</a> <a href="amos_users_guide.html#subqueries">aggregate
      function</a> <span style="font-style: italic;">groupby</span> has
    the signature:<br>
    <pre>groupby(Bag of (Object,Object) sq, Function aggfn) -&gt; Bag of (Object gk, Object aggv)</pre>
    The bag <span style="font-style: italic;">sq</span> contains
    key-value pairs&nbsp; <span style="font-style: italic;">(k, v)</span>
    where <span style="font-style: italic;">k</span> is called a <span
      style="font-style: italic;">group key</span> and <span
      style="font-style: italic;">v</span> is an arbitrary value paired
    with <span style="font-style: italic;">k</span>.&nbsp; The result
    is a bag of new key-value pairs <span style="font-style: italic;">(gk,



      aggv)</span> where <span style="font-style: italic;">gk</span> is
    each distinct group key <span style="font-style: italic;"></span>in
    <span style="font-style: italic;">sq</span> and <span
      style="font-style: italic;">aggv</span> is the result of applying
    <span style="font-style: italic;">aggfn</span> on the bag of the
    values paired with <span style="font-style: italic;">gk</span>.<br>
    <h3><a name="vector-numerical"></a>2.7.3 Numerical vector functions</h3>
    The <span style="font-style: italic;">times </span>function (*
    infix operator) is defined as the scalar product for vectors of
    numbers:<br>
    <span style="font-family: monospace;">&nbsp; times(Vector x, Vector
      y) -&gt; Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} * {4, 5, 6};</span><br>
    returns the number 32.<br>
    <br>
    The <span style="font-style: italic;">elemtimes </span>function
    (.* infix operator) is defined as the element wise product for
    vectors of numbers:<br>
    <span style="font-family: monospace;">&nbsp; elemtimes(Vector x,
      Vector y) -&gt; Vector of Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} .* {4, 5, 6};</span><br>
    returns <span style="font-family: monospace;">{4, 10, 18}</span>.<br>
    <br>
    The <span style="font-style: italic;">elemdiv </span>function (./
    infix operator) is defined as the element wise fractions for vectors
    of numbers:<br>
    <span style="font-family: monospace;">&nbsp; elemdiv(Vector x,
      Vector y) -&gt; Vector of Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} ./ {4, 5, 6};</span><br>
    returns <span style="font-family: monospace;">{0.25, 0.4, 0.5}</span>.<br>
    <br>
    The <span style="font-style: italic;">elempower </span>function
    (.^ infix operator) is defined as the element wise power for vectors
    of numbers:<br>
    <span style="font-family: monospace;">&nbsp; elempower(Vector of
      Number x, Number exp) -&gt; Vector of Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} .^ 2;</span><br>
    returns <tt>{1, 4, 9}</tt>.<br>
    <br>
    The <span style="font-style: italic;">plus </span> and <span
      style="font-style: italic;">minus </span>functions (+ and - infix
    operators) are defined as the element wise sum and difference for
    vectors of numbers, respectively:<br>
    <span style="font-family: monospace;">&nbsp; plus(Vector of number
      x, Vector of number y) -&gt; Vector of Number r</span><br>
    <span style="font-family: monospace;">&nbsp; minus(Vector of number
      x, Vector of number y) -&gt; Vector of Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} + {4, 5, 6};</span><br>
    returns <span style="font-family: monospace;">{5, 7, 9}</span> and<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} - {4, 5, 6};</span><br>
    returns <span style="font-family: monospace;">{-3, -3, -3}</span>.<br>
    <br>
    <i>Times</i> and <i>div</i> functions (* and / infix operators)
    scale vectors by a scalar:<br>
    <tt>&nbsp; times(Vector of number x,Number y) -&gt; Vector of Number
      r</tt><br>
    <tt>&nbsp; div(Vector of number x,Number y) -&gt; Vector of Number r</tt><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; {1, 2, 3} * 1.5;</span><br>
    returns <span style="font-family: monospace;">{1.5, 3.0, 4.5}</span><br>
    <br>
    For user convenience, <i>plus</i> and <i>minus</i> functions (+
    and - infix operators) allow mixing vectors and scalars:<br>
    <tt>&nbsp; plus(Vector of Number x, Number y) -&gt; Vector of Number
      r</tt><br>
    <tt>&nbsp; minus(Vector of Number x, Number y) -&gt; Vector of
      Number r </tt><br>
    For example:<br>
    <tt>&nbsp; {1, 2, 3} + 10;</tt><br>
    returns <tt>{11, 12, 13}</tt> and<br>
    <tt>&nbsp; {1, 2, 3} - 10;</tt><br>
    returns <tt>{-9, -8, -7}</tt>.<br>
    <br>
    These functions can be used in queries too:<br>
    <tt>&nbsp; select lambda from number lambda where {1, 2} - lambda =
      {11, 12};</tt><br>
    returns <tt>-10</tt>.<br>
    <br>
    If the equation has no solution, the query will have no result:<br>
    <tt>&nbsp; select lambda from number lambda where {1, 3} - lambda =
      {11, 12};</tt><br>
    <br>
    By contrast, note that this query will have a result:<br>
    <tt>&nbsp; select lambda from vector of number lambda where {1, 2} -
      lambda = {11, 12};</tt><br>
    returns <tt>{-10,-9}</tt>.<br>
    <br>
    <span style="font-family: Times New Roman;">The functions <i>zeros</i>
      and <i>ones</i> generate vectors of zeros and ones, respectively:<br>
      <span style="font-family: monospace;"> &nbsp; zeros(Integer)-&gt;
        Vector of Number<br>
        &nbsp; ones(Integer)-&gt; Vector of Number</span><br>
      For example:<br>
      <span style="font-family: monospace;">&nbsp; zeros(5);<br>
      </span>&nbsp;results in <span style="font-family: monospace;">{0,
        0, 0, 0, 0}</span><br>
      <span style="font-family: monospace;">&nbsp; 3.1 * ones(4);<br>
      </span>&nbsp;results in <span style="font-family: monospace;">{3.1,



        3.1, 3.1, 3.1}</span><br>
      <br>
    </span>The function <i>roundto</i> rounds each element in a vector
    of numbers to the desired number of decimals:<br>
    <span style="font-family: monospace;">&nbsp; roundto(Vector of
      Number v, Integer d) -&gt; Vector of Number r</span><br>
    For example:<br>
    <span style="font-family: monospace;">&nbsp; roundto({3.14159,
      2.71828}, 2);<br>
    </span>&nbsp;returns <span style="font-family: monospace;">{3.14,
      2.72}</span><br>
    <br>
    <a name="statistical-functions"></a>The function <span
      style="font-style: italic;">vavg</span> computes the average value
    <span style="font-style: italic;">a</span> of a vector of numbers <span
      style="font-style: italic;">v</span>:<br>
    <span style="font-family: monospace;">&nbsp; vavg(Vector of Number
      v) -&gt; Real a</span><br>
    <br>
    The function <span style="font-style: italic;">vstdev</span>
    computes the standard deviation <span style="font-style: italic;">s</span>
    of a vector of numbers <span style="font-style: italic;">v</span>:<br>
    <span style="font-family: monospace;">&nbsp; vstdev(Vector of Number
      v) -&gt; Real s</span><br>
    <br>
    The function <span style="font-style: italic;">median </span>computes
the




    median <span style="font-style: italic;">m</span> of a vector of
    numbers <span style="font-style: italic;">v</span>:<br>
    <span style="font-family: monospace;">&nbsp; median(Vector of Number
      v) -&gt; Number m<br>
      <br>
    </span><span style="font-family: Times New Roman;"><a
        name="distance-functions"></a>The function <span
        style="font-style: italic;">euclid</span> computes the Euclidean
      distance between two points <span style="font-style: italic;">p1</span>
      and <span style="font-style: italic;">p2</span> expressed as
      vectors of numbers:<br>
    </span><span style="font-family: monospace;">&nbsp; euclid(Vector of
      Number p1, Vector of Number p2) -&gt; Real d</span><span
      style="font-family: Times New Roman;"><br>
      <br>
      The function <i>minkowski</i> computes the Minkowski distance
      between two points <i>p1</i> and <i>p2</i> expressed as vectors
      of numbers, with the Minkowski parameter <i>r</i>:<br>
      <span style="font-family: monospace;">&nbsp; minkowski(Vector of
        Number p1, Vector of Number p2, Real r) -&gt; Real d</span><br>
      <br>
      The function <i>maxnorm</i> computes the Maxnorm distance between
      two points <i>p1</i> and <i>p2</i> (conceptually, this is the
      same as the Minkowski distance with <i>r</i> = infinity):<br>
      <span style="font-family: monospace;">&nbsp; maxnorm(Vector of
        Number p1, Vector of Number p2) -&gt; Real d</span></span><br>
    <h3><span style="font-family: Times New Roman;"><a
          name="vector-aggregate"></a>2.7.4 Vector aggregate functions</span></h3>
    <span style="font-family: Times New Roman;">The following functions
      group and compute aggregate values over collections of numerical
      vectors.<br>
      <br>
      <a name="aggv"></a> Dimension-wise aggregates over bags of vectors
      can be computed using the function <i>aggv</i>:<br>
      <span style="font-family: monospace;">&nbsp; aggv(Bag of Vector,
        Function) -&gt; Vector</span><br>
      For example:<br>
      <span style="font-family: monospace;">&nbsp; aggv((select {i, i +
        10}<br>
        &nbsp;&nbsp;&nbsp;from integer i<br>
        &nbsp;&nbsp;&nbsp;where i in <a href="#iota">iota</a>(1, 10)),
        <a href="#functional-constant">#'avg'</a>);<br>
      </span>&nbsp;results in <span style="font-family: monospace;">{5.5,



        15.5}</span><br>
      <br>
      <a name="vnorm"></a> Each dimension in a bag of vector of number
      can be normalized using one of the normalization functions <i>meansub</i>,
      <i>zscore</i>, or <i>maxmin</i>. They all have the same
      signature:<br>
      <pre>meansub(Bag of Vector of Number b) -&gt; Bag of Vector of Number<br>zscore(Bag of Vector of Number b) -&gt; Bag of Vector of Number<br>maxmin(Bag of Vector of Number b) -&gt; Bag of Vector of Number<br></pre>
      <i>meansub</i> transforms each dimension to a <i>N(0, s)</i>
      distribution (assuming that the dimension was <i>N(u, s)</i>
      distributed) by subtracting the mean <i>u</i> of each dimension.
      <i>zscore</i> transforms each dimension to a <i>N(0, 1)</i>
      distribution by also dividing by the standard deviation of each
      dimension. <i>maxmin</i> transforms each dimension to be on the
      [0, 1] interval by applying the transformation <span
        style="font-family: monospace;">(w - min) ./ (max - min)</span>
      to each vector <i>w</i> in bag <i>b</i> where <i>max</i> and <i>min</i>
      are computed using <span style="font-family: monospace;">aggv(b,
        <a href="#functional-constant">#'maxagg'</a>)</span> and <span
        style="font-family: monospace;">aggv(b, #'minagg')</span>
      respectively.<br>
      For example:<br>
      <pre>meansub((select {i, i/2 + 10}<br>         from integer i<br>         where i in <a href="#iota">iota</a>(1, 5)));<br></pre>
      &nbsp;results in
      <pre>{-2.0,-1.0}<br>{-1.0,-0.5}<br>{0.0,0.0}<br>{1.0,0.5}<br>{2.0,1.0}<br></pre>
      Principal Component Analysis is performed using the function <i>PCA</i>:<br>
      <span style="font-family: monospace;"> &nbsp; pca(Bag of Vector
        data)-&gt; (Vector of Number eigval D, Vector of Vector of
        Number eigvec W)</span><br>
      <i>PCA</i> takes a bag of <i>M</i>-dimensional vectors in <i>data</i>
      and computes the <i>M</i>x<i>M</i> covariance matrix <i>C</i> of
      the input vectors. Then, <i>PCA</i> computes the <i>M</i>
      eigenvalues <i>D</i> and the <i>M</i>x<i>M</i> eigenvector
      matrix <i>W</i> of the covariance matrix. <i>PCA</i> returns the
      eigenvalues <i>D</i> and their corresponding eigenvectors <i>W</i>.<br>
      <br>
      To use <i>PCA</i> to reduce the dimensionality to the <i>L</i>
      most significant dimensions, each input vector must be projected
      onto the eigenvectors corresponding to the <i>L</i> greatest
      eigenvalues using the scalar product. This is done using the
      function <i>PCASCORE</i>:<br>
      <tt>&nbsp; pcascore(Bag of Vector of Number, Integer d) -&gt;
        Vector of Number score</tt><br>
      <i>PCASCORE</i> performs PCA on <i>data</i>, and projects each
      data vector in <i>data</i> onto the <i>d</i> first eigenvectors.
      Each projected vector in <i>data</i> is emitted.<br>
      The function <i>LPCASCORE</i> allows a label to be passed along
      with each vector:<br>
      <tt>&nbsp; lpcascore(Bag of (Vector of Number, Object label),
        Integer d) -&gt; (Vector of Number score, Object label)</tt><br>
      The label of each vector remains unchanged during projection.<br>
      <br>
      Note that the input data might have to be pre-processed, using
      some <a href="#vnorm">vector normalization</a>.<br>
      <br>
      <h3><a name="plot"></a>2.7.5 Plotting numerical data</h3>
      AmosII can utilize GNU Plot (v 4.2 or above), to plot numerical
      data. The <i>plot</i> function is used to plot a line connecting
      two-dimensional points. Each vector in the vector <tt>v</tt> is a
      data point. <i>plot</i> will plot the points in the order they
      appear in the <i>v</i>.<br>
      <tt>&nbsp; plot(Vector of Vector v) -&gt; Integer</tt><br>
      The return value is the exit code of the plot program. A nonzero
      value indicates error.<br>
      If the data points have a higher dimensionality than two, the
      optional argument <i>projs</i> is used to select the dimension to
      be plotted.<br>
      <tt>&nbsp; plot(Vector of Integer projs, Vector of Vector v) -&gt;
        Integer</tt><br>
      The <tt>projs</tt> vector lists the dimensions onto which each
      data vector is to be projected. The first dimension has number 0
      (zero).<br>
      <br>
      Scatter plots of bags of two-dimensional vectors are generated
      using <i>scatter2</i>.<br>
      <i>scatter2p</i> and <i>scatter2l</i> plots three-dimensional
      data in two dimensions. <i>scatter2p</i> assigns a color
      temperature of each point according to the value of its value in
      the third dimension. <i>scatter2l</i> labels each point in the
      two-dimensional plot with the its value of the third dimension.
      The value of the third dimension in <i>scatter2l</i>could be
      numerical or textual.<br>
      <br>
      Three-dimensional scatter plots are generated using <i>scatter3</i>,
      <i>scatter3l</i>, and <i>scatter3p</i>. <i>scatter3</i> plots
      3-dimensional data, whereas <i>scatter3l</i> and <i>scatter3p</i>
      plot 4-dimensional data in the same fahsion as <i>scatter2p</i>
      and <i>scatter2l</i>.<br>
      Each scatter plot function have two different signatures:
      <pre>scatter2(Bag of Vector v) -&gt; Integer <br>scatter2l(Bag of Vector v) -&gt; Integer <br>scatter2p(Bag of Vector v) -&gt; Integer <br>scatter3(Bag of Vector v) -&gt; Integer <br>scatter3l(Bag of Vector v) -&gt; Integer <br>scatter3p(Bag of Vector v) -&gt; Integer<br>scatter2(Vector of Integer projs, Bag of Vector v) -&gt; Integer <br>scatter2l(Vector of Integer projs, Bag of Vector v) -&gt; Integer <br>scatter2p(Vector of Integer projs, Bag of Vector v) -&gt; Integer <br>scatter3(Vector of Integer projs, Bag of Vector v) -&gt; Integer <br>scatter3l(Vector of Integer projs, Bag of Vector v) -&gt; Integer <br>scatter3p(Vector of Integer projs, Bag of Vector v) -&gt; Integer<br><br></pre>
      <h2><a name="2.8_Accessing_data_in_files"></a>2.8 Accessing data
        in files</h2>
      The file system where an Amos II peer is running can be access
      with a number of system functions:<br>
      <br>
      The function <span style="font-style: italic;">pwd</span> returns
      the path to the current working directory of the peer:<br>
    </span><span style="font-family: monospace;">&nbsp; pwd() -&gt;
      Charstring path</span><span style="font-family: monospace;"><br>
      <br>
    </span>The function <span style="font-style: italic;">cd</span>
    changes the current working directory of the peer:<br>
    <span style="font-family: monospace;">&nbsp; cd(Charstring path)
      -&gt; Charstring </span><span style="font-family: monospace;"><br>
    </span><br>
    The function <span style="font-style: italic;">dir</span> returns a
    bag of the files in a directory<span style="font-style: italic;"></span>:<br>
    <span style="font-family: monospace;">&nbsp; dir() -&gt; Bag of
      Charstring file<br>
      &nbsp; dir(Charstring path) -&gt; Bag of Charstring file<br>
      &nbsp; dir(Charstring path, Charstring pat) -&gt; Bag of
      Charstring file<br>
    </span>The first optional argument <span style="font-style:
      italic;">path</span> specifies the path to the directory. The
    second optional argument <span style="font-style: italic;">pat</span>
    specifies a regular expression (as in like) to match the files to
    return.<br>
    <br>
    The function <span style="font-style: italic;">file_exists</span>
    returns true if a file with a given name exists<span
      style="font-style: italic;"></span>:<br>
    <span style="font-family: monospace;">&nbsp; file_exists(Charstring
      file) -&gt; Boolean</span><br>
    <br>
    The function <span style="font-style: italic;">directoryp</span>
    returns true if a path is a directory:<br>
    <span style="font-family: monospace;">&nbsp; directoryp(Charstring
      path) -&gt; Boolean</span><br>
    <br>
    The function <span style="font-style: italic;">filedate</span>
    returns the write time of a file with a given name<span
      style="font-style: italic;"></span>:<br>
    <span style="font-family: monospace;">&nbsp; filedate(Charstring
      file) -&gt; Date</span><br>
    <span style="font-family: Times New Roman;"><br>
      <h3><a name="read_ntuples"></a>2.8.1 Reading tuples from a file</h3>
      The function <i>read_ntuples</i> imports data from a text file.
      Each line of the text file is imported into one vector. Each token
      on a line will be parsed into field in the vector. Numbers in the
      file are parsed into numbers. All other tokens are parsed into
      strings.<br>
      For example, if a file name <i>test</i> contains the following:<br>
      <pre>"This is the first line" another word<br>1 2 3 4.45 2e9<br>"This line is parsed into two fields" 3.14</pre>
      Then, <tt>read_ntuples("test");</tt> returns
      <pre>{"This is the first line","another","word"}<br>{1,2,3,4.45,2000000000.0}<br>{"This line is parsed into two fields",3.14}</pre>
      <h2><a name="cursors"></a> 2.9 Cursors</h2>
      Cursors provide a way to iterate over the result of a query or a
      function call or the value of a variable. The <tt>open-cursor-stmt</tt>
      opens a new <span style="font-style: italic;">scan</span> on the
      result of a query, function call, or variable binding. A scan is a
      data structure holding a current element, the <span
        style="font-style: italic;">cursor</span>, of a potentially very
      large bag produced by a query, function call, or variable binding.
      The next element in the bag is retrieved by the<tt>
        fetch-cursor-stmt</tt>. Every time a </span><span
      style="font-family: Times New Roman;"><tt>fetch-cursor-stmt</tt></span><span
      style="font-family: Times New Roman;"> statement is executed the
      cursor is moved forward over the bag. When the end of the bag is
      reached the </span><span style="font-family: Times New Roman;"><tt>fetch-cursor-stmt</tt></span><span
      style="font-family: Times New Roman;"> returns empty result. The
      user can test whether there is any more elements in a scan by
      calling one of the functions<br>
    </span><span style="font-family: monospace;">&nbsp;&nbsp; more(Scan
      s)&nbsp;&nbsp; -&gt; Boolean<br>
      &nbsp;&nbsp; nomore(Scan s) -&gt; Boolean<br>
    </span><span style="font-family: Times New Roman;">that test whether
      the scan is has more rows or not, respectively. </span><span
      style="font-family: Times New Roman;"><br>
      <p>Syntax: </p>
      <pre>open-cursor-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'open' cursor-name 'for' <a href="#expressions">expr</a> <br><br>cursor-name ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#variables">variable</a>&nbsp;<br><br><a name="fetch-statement"></a>fetch-cursor-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'fetch' cursor-name into-clause <br><br>close-cursor-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'close' cursor-name</pre>
      For example:
      <pre>create person (name,age) instances :Viola ('Viola',38);<br>open :c1&nbsp; for (select p from Person p where name(p) = 'Viola');&nbsp;<br>fetch :c1 into :Viola1;<br>close :c1;&nbsp;<br>name(:Viola1);&nbsp;<br>--&gt; "Viola";</pre>
      <p>The<tt> fetch-cursor-stmt</tt> fetches the next result tuple
        from the scan; i.e. the tuple is removed from the scan.&nbsp; </p>
      <p>If present in a <tt>fetch-cursor-stmt</tt>, the <tt>into</tt>
        clause will bind elements of the first result tuple to AmosQL
        interface variables. There must be one interface variable for
        each element in the next cursor tuple. </p>
      <p>If no <span style="font-family: monospace;">into</span> clause
        is present in a<tt> fetch-cursor-stmt</tt>, a single result
        tuple is fetched and displayed. </p>
      <p>The<tt> close-cursor-stmt</tt> deallocates the scan. <br>
      </p>
      <p>Cursors allow iteration over very large bags created by queries
        or function calls. For example,<br>
      </p>
    </span>
    <pre>set :b = (select <a href="#iota">iota</a>(1,1000000)+iota(1,1000000)); <br>/* :b contains a bag with 10**12 elements! */<br><br>open :c for :b;<br>fetch :c;<br>-&gt; 2<br>fetch :c;<br>-&gt; 3<br>etc.<br>close :c; </pre>
    <span style="font-family: Times New Roman;"></span><span
      style="font-family: Times New Roman;">
      <p>Cursors are implemented using a special datatype called <span
          style="font-style: italic;">Scan</span> that allows iterating
        over very large bags of tuples. The following functions are
        available for accessing the tuples in a scan as vectors:<br>
      </p>
    </span><span style="font-family: Times New Roman;">
      <p><span style="font-family: monospace;">next(Scan s)-&gt;Vector</span><br>
        moves the cursor to the next tuple in a scan and returns the
        cursor tuple. The <a href="#fetch-statement">fetch-cursor-statement</a>
        is based on this function.<br>
      </p>
    </span><span style="font-family: Times New Roman;">
      <p><span style="font-family: monospace;">this(Scan s)-&gt;Vector</span><br>
        returns the current tuple in a scan without moving the cursor
        forward.<br>
      </p>
    </span><span style="font-weight: bold;">Notice</span> that <a
      href="#cursors">cursors</a> can be used as an alternative to the
    for-each statement for iterating over the result of a bag. The
    for-each statements is faster than iterating with cursors but it
    cannot be used for simultanously iterating over several bags such as
    is done by the <a href="#sumb2">sumb2</a> example function.<br>
    <span style="font-family: Times New Roman;">
      <p><span style="font-family: monospace;">peek(Scan s)-&gt;Vector</span><br>
        returns the next tuple in a scan without moving the cursor
        forward.<br>
      </p>
      <h1><a name="procedures"></a>3 Procedural functions<br>
      </h1>
      A procedural function is an Amos II function defined as a sequence
      of AmosQL statements that may have side effects (e.g. database
      update statements). Procedural functions may return a bag of
      results by using a special <tt>return</tt> statement. Each time <tt>return</tt>
      is called another result ba element is emitted from the function.
      Procedural functions should not be used in queries. However, this
      restriction is currently not enforced. Most, but not all, AmosQL
      statements are allowed in procedure bodies as can be seen by the
      syntax below.
      <p>Syntax:&nbsp; </p>
      <pre><a name="procedure-body"></a>procedural-function-definition ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block | procedure-stmt<br>    <br>    procedure-stmt ::=<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#create-object">create-object-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#object-deletion">delete-object-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#foreach-statement">for-each-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#updates">update-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#add-type">add-type-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#add-type">remove-type-stmt</a> |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#set-local-variable-stmt">set-local-variable-stmt</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#query-statement">query</a> |&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if-stmt |<br>        <a href="#commit">commit-stmt</a> |<br>        <a href="#rollback">abort-stmt</a> |<br>        loop-stmt |<br>        while-stmt |<br>        <a href="#cursors">open-cursor-stmt</a> |<br>        <a href="#cursors">fetch-cursor-stmt</a> |<br>        <a href="#cursors">close-cursor-stmt</a><br><br>&nbsp;&nbsp;&nbsp; block ::=&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'begin'&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['declare' <a href="#variable-declaration">variable-declaration-commalist</a> ';']&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#procedure-body">procedure-stmt-semicolonlist</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'end'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp; <a name="result"></a>return-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'return' <a href="#expressions">expr</a>&nbsp;<br><br>&nbsp;&nbsp;&nbsp; for-each-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'for each' [for-each-option] <a href="#variable-declaration">variable-declaration-commalist</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    [<a href="#select-statement">where-clause</a>] for-each-body&nbsp;<br><br>    for-each-option ::= 'distinct' | 'copy'<br><br>    for-each-body ::= <a href="#procedure-body">procedure-body</a><br><br>&nbsp;&nbsp;&nbsp; if-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'if' <a href="#expressions">expr</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'then' <a href="#procedure-body">procedure-body</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ['else' <a href="#procedure-body">procedure-body</a>]&nbsp;<br><br><a name="set-local-variable-stmt"></a>     set-local-variable-stmt ::=&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'set' <a href="#variables">local-variable</a> '=' <a href="#expressions">expr</a><br>    <br>    while-stmt ::=<br>        'while' <a href="#expressions">expr</a> 'do' <a href="#procedure-body">procedure-stmt-semicolonlist</a> 'end while'<br><br>    loop-stmt ::=<br>        'loop' <a href="#procedure-body">procedure-stmt-semicolonlist</a> 'end loop'<br><br>    leave-stmt ::=<br>        'leave'<br></pre>
      Examples:&nbsp;
      <pre>&nbsp;create function creperson(Charstring nm,Integer inc) -&gt; Person p&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create Person instances p;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set name(p)=nm;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set income(p)=inc;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;<br><br>&nbsp;set :p = creperson('Karl',3500);&nbsp;<br><br>&nbsp;create function makestudent(Object o,Integer sc) -&gt; Boolean&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as add type Student(score) to o (sc);&nbsp;<br><br>&nbsp;makestudent(:p,30);&nbsp;<br><br>&nbsp;create function flatten_incomes(Integer threshold) -&gt; Boolean&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as for each Person p where income(p) &gt; threshold&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set income(p) = income(p) -&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (income(p) - threshold) / 2;<br><br>&nbsp;flatten_incomes(1000);<br><br> <a name="sumb2"></a>create function sumb2(Bag of Number b1, Bag of Number b2)-&gt;Number<br>   as begin declare Number r, Number x1, Number x2, Scan c1, Scan c2;<br>            open c1 for b1;<br>            open c2 for b2;<br>            set r = 0;<br>            while more(c1) and more(c2)<br>            do fetch c1 into x1;<br>               fetch c2 into x2;<br>               set r = r + x1*x2;<br>               return r;<br>            end while;<br>      end;<br> <br>sumb2(<a href="#iota">iota</a>(1,10),iota(10,20));<br></pre>
      <span style="font-weight: bold;">Notice</span> that queries and
      updates embedded in procedure bodies are optimized at compile
      time. The compiler saves the optimized query plans in the database
      so that dynamic query optimization is not needed when procedural
      functions are executed.&nbsp; <br>
      <p>A procedural function may return a bag of result values
        iteratively. The<tt> <a href="#result">return-stmt</a></tt>
        statement is used for this, where an element of the result bag<span
          style="font-family: monospace;"></span> is returned every time
        it is executed.&nbsp; <span style="font-family: Times New
          Roman;">The <a href="#result"><tt>return-stmt</tt></a> does
          not not abort the control flow (different from, e.g., return
          in C), but it only specifies that a value is to be emitted to
          the return bag of the function and then the procedure
          evaluation is continued as usual. </span>If <a
          href="#result"><span style="font-family: Times New Roman;"><tt>return-stmt</tt></span></a>
        is never called the result of the procedural function is empty.
        Usually the result type of procedural functions not returning
        any value is <tt>Boolean</tt>.<br>
      </p>
      <h2><a name="foreach-statement"></a>3.1 Iterating over results<br>
      </h2>
      <p>The <tt>for-each</tt> statement iterates over the result of
        the query specified by the variable declarations (<a
          href="#variable-declaration"><tt>variable-declaration-commalist</tt></a>)
        and the where clause executing the <tt>for-each-body</tt> for
        each result variable binding of the query. For example the
        following function adds <tt>inc</tt> to the incomes of all
        persons with salaries higher than <tt>limit</tt> and returns
        their <i>old</i> incomes:&nbsp; </p>
      <pre>&nbsp;create function increase_incomes(Integer inc,Integer limit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; Integer oldinc&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as for each Person p, Integer i&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where i &gt; limit&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and i = income(p)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return i;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set income(p) = i + inc&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;</pre>
      The<tt> for-each-stmt</tt> does not return any value at all unless<tt>
        <a href="#result">return-stmt</a></tt> is called within its
      body. &nbsp; <br>
      <br>
      The <tt>for-each-option</tt> specifies how to treat the result of
      the query iterated over. If it is omitted the system default is to
      iterate directly over the result of the query while immediately
      applying the <tt>for-each-body</tt> on each retrieved element. If
      '<tt>distinct</tt>' is specified the iteration is over a copy
      where duplicates in addition have been removed. If &nbsp;the
      option is '<tt>copy</tt>' the code is applied on a copy of the
      result of the query. <br>
      <br>
    </span>
    <h1><a name="SQL-processor"></a>4 The SQL processor</h1>
    <span style="font-family: Times New Roman;">
      <p>Amos II databases can be manipulated using SQL as an
        alternative to AmosQL. The SQL preprocessor translates SQL
        commands to corresponding AmosQL statements. The SQL
        preprocessor is called using a special foreign function:<br>
      </p>
    </span>
    <pre>sql(Charstring query)-&gt;Bag of vector result</pre>
    <span style="font-family: Times New Roman;">
      <p>To make an Amos II function be queried using SQL its name must
        be prefixed with '<span style="font-family: monospace;">sql:</span>'.



        Thus an Amos II function whose name is <span
          style="font-family: monospace;">sql:</span><span
          style="font-style: italic;">&lt;table&gt;</span> can be
        regarded as a table named <span style="font-style: italic;">&lt;table&gt;</span>
        which is queried and updated using SQL statements passed as
        argument to the foreign function <span style="font-style:
          italic;">sql</span>. <br>
        <br>
        For example, assume we define the stored functions:<br>
      </p>
    </span>
    <pre>create function sql:employee(Integer ssn) -&gt; (Charstring name, Number Income, Integer dept) as stored;</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>create function sql:dept(Integer dno) -&gt; Charstring dname as stored;<br></pre>
    <span style="font-family: Times New Roman;">
      <p>Then we can populate the tables by the following calls to the
        sql function:<br>
      </p>
    </span>
    <pre>sql("insert into employee values (12345, &#8216;Kalle&#8217;, 10000, 1)");</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>sql("insert into employee values (12386, &#8216;Elsa&#8217;, 12000, 2)");</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>sql("insert into employee values (12493, &#8216;Olof&#8217;, 5000, 1)");</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>sql("insert into dept values(1,&#8217;Toys&#8217;)");</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>sql("insert into dept values(2,&#8217;Cloths&#8217;)");<br></pre>
    <span style="font-family: Times New Roman;">
      <p>Examples of SQL queries are:<br>
      </p>
    </span>
    <pre>sql("select ssn from employee where name = &#8216;Kalle&#8217;");</pre>
    <span style="font-family: Times New Roman;"></span>
    <pre>sql("select dname from dept, employee where dept = dno and name=&#8217;Kalle&#8217;");<br></pre>
    <span style="font-family: Times New Roman;">
      <p>The parser is based on the SQL-92 version of SQL. <span
          style="font-family: Times New Roman;">Thus, the SQL processor
          allows an Amos II database be both updated and queried using
          SQL-92. The parser</span> passes most of the SQL-92 validation
        test.&nbsp; However, SQL views are not supported. For further
        details see <a
href="http://www.it.uu.se/research/group/udbl/Theses/MarkusJagerskoghMSc.pdf">http://www.it.uu.se/research/group/udbl/Theses/MarkusJagerskoghMSc.pdf</a>.<br>
      </p>
      <p>The command line option <br>
      </p>
    </span>
    <pre>        amos2 ... -q sql...</pre>
    <span style="font-family: Times New Roman;">
      <p> will make Amos II accept SQL as query language in the top loop
        rather than AmosQL.<br>
      </p>
      <h1><a name="peers"></a> 5 Peer management<br>
      </h1>
      Using a basic Amos II peer communication system, distributed Amos
      II peers can be set up that communicate using TCP/IP. A federation
      of Amos II peers is managed by a <span style="font-style:
        italic;">name server</span> which is an Amos II peer knowing
      addresses and names of other Amos II peers. Queries, AmosQL
      commands, and results can be shipped between peers. Once a
      federation is set up, multi-database facilities can be used for
      defining queries and views spanning several Amos II peers <a
        href="#RJK03">[RJK03]</a>. Mediation&nbsp; and reconciliation
      primitives can be used for defining object-oriented multi-peer
      views <a href="file:///C:/AmosNT/doc/amos_users_guide.html#JR99a">[JR99a]</a><a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#JR99b">[JR99b]</a>.<br>
      <h2>5.1 Peer communication</h2>
      The following AmosQL system functions are available for inter-peer
      communication:<br>
      <p><tt>&nbsp;&nbsp; nameserver(Charstring name)-&gt;Charstring</tt>
        <br>
        The function makes the current stand-alone database into a name
        server and registers there itself as a peer with the given <tt>name</tt>.
        If name is empty ("") the name server will become <i>anonymous</i>
        and not registered as a peer. It can be accessed under the peer
        name "NAMESERVER" through.<br>
      </p>
      <p><tt>&nbsp;&nbsp; listen()</tt> <br>
        The function starts the peer listening loop. It informs the name
        server that this peer is ready to receive incoming messages. The
        listening loop can be interrupted with CTRL-C and resumed again
        by calling <span style="font-style: italic;">listen()</span>.
        The name server must be listening before any other peer can
        register. </p>
      <p><tt>&nbsp;&nbsp; register(Charstring name)-&gt;Charstring</tt>
        <br>
        The function registers in the name server the current
        stand-alone database as a peer with the given <span
          style="font-style: italic;">name</span><tt>.&nbsp;</tt> The
        system will complain if the name is already registered in the
        name server. &nbsp;The peer needs to be activated with <span
          style="font-style: italic;">listen()</span> to be able to
        receive incoming requests. The name server must be running on
        the local host. <br>
      </p>
      <p><tt>&nbsp;&nbsp; register(Charstring name, Charstring
          host)-&gt;Charstring</tt> <br>
        Registers the current database as a peer in the federation name
        server running on the given <span style="font-style: italic;">host</span>.
        Signals error if peer with same name already registered in
        federation.<br>
      </p>
      <p><tt>&nbsp; &nbsp;reregister(Charstring name)-&gt;Charstring<br>
          &nbsp; &nbsp;reregister(Charstring name, Charstring
          host)-&gt;Charstring</tt><br>
        as<tt> </tt><span style="font-style: italic;">register</span>
        but first unregisters another registered peer having same name
        rather than signaling error. Good when restarting peer
        registered in name server after crash so the crashed peer will
        be unregistered. &nbsp; </p>
      <p><tt>&nbsp;&nbsp; this_amosid()-&gt;Charstring name</tt> <br>
        Returns the <tt>name</tt> of the peer where the call is issued.
        Returns the string <tt>"NIL"</tt> if issued in a not registered
        standalone Amos II system.</p>
      <p><tt>&nbsp;&nbsp; other_peers()-&gt;Bag of Charstring name</tt>
        <br>
        Returns the <tt>name</tt>s of the other peers in the federation
        managed by the name server.</p>
      <p><tt>&nbsp;&nbsp; ship(Charstring peer, Charstring cmd)-&gt; Bag
          of Vector</tt> <br>
        Ships the AmosQL command <span style="font-style: italic;">cmd</span>
        for execution in the named peer. The result is shipped back to
        the caller as a set of tuples represented as <a href="#vector">vectors</a>.
        &nbsp;If an error happens at the other peer the error is also
        shipped back.<br>
      </p>
      <p><span style="font-family: Times New Roman;"><tt>&nbsp;&nbsp;
            call_function(Charstring peer, Charstring fn, Vector args,
            Integer stopafter)-&gt; Bag of Vector</tt> <br>
          Calls the Amos II function named <span style="font-style:
            italic;">fn</span> with argument list <span
            style="font-style: italic;">args</span> in <span
            style="font-style: italic;">peer</span>. The result is
          shipped back to the caller as a set of tuples represented as <a
            href="amos_users_guide.html#vector">vectors</a>. The maximum
          number of tuples shipped back is limited by <span
            style="font-style: italic;">stopafter</span>. If an error
          happens at the other peer the error is also shipped back.<br>
          <br>
        </span><tt>&nbsp;&nbsp; send(Charstring peer, Charstring
          cmd)-&gt; Charstring peer</tt> <br>
        Sends the AmosQL command <span style="font-style: italic;">cmd</span>
        for asynchronous execution in the named peer without waiting for
        the result to be returned. Errors are handled at the other peer
        and <span style="font-style: italic;">not </span>shipped back.<br>
      </p>
      <p><span style="font-family: Times New Roman;"><tt>&nbsp;&nbsp;
            send_call(Charstring peer, Charstring fn, Vector args)-&gt;
            Boolean</tt> <br>
          Calls the Amos II function named <span style="font-style:
            italic;">fn</span> with argument list <span
            style="font-style: italic;">args</span> asynchronously in
          the named <span style="font-style: italic;">peer</span>
          without waiting for the result to be returned. Errors are
          handled at the other peer and <span style="font-style:
            italic;">not </span>shipped back.</span> </p>
      <p><tt>&nbsp;&nbsp; broadcast(Charstring cmd)-&gt; Bag of
          Charstring</tt><br>
        Sends the AmosQL command <span style="font-style: italic;">cmd</span>
        for asynchronous execution in all other peers. Returns the names
        of the receiving peers.<br>
      </p>
      <p><tt>&nbsp; &nbsp;hostname()-&gt;Charstring name</tt><br>
        Returns the name of the host where the current peer is running.<br>
      </p>
      <p><tt>&nbsp; &nbsp;kill_peer(Charstring name)-&gt;Charstring</tt><br>
        Kills the named peer. If the peer is the name server it will not
        be killed, though. Returns the name of the killed peer.<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          kill_all_peers()-&gt;Bag of Charstring</span><br>
        Kills all peers. The name server and the current peer will still
        be alive afterwards. Returns the names of the killed peers.<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          kill_the_federation()-&gt;Boolean</span><br>
        Kills all the peers in the federation, including the name server
        and the peer calling <span style="font-style: italic;">kill_the_federation</span>.<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          is_running(Charstring&nbsp; peer)-&gt;Boolean</span><br>
        Returns <span style="font-style: italic;">true</span> if peer
        is listening.<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          wait_for_peer(Charstring peer)-&gt;Charstring</span><br>
        Waits until the peer is running and then returns the peer name.</p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          amos_servers()-&gt;Bag of Amos</span><br>
        Returns all peers managed by the name server on this computer.
        You need not be member of federation to run the function.</p>
      <h2><a name="peer-views"></a>5.2 Peer queries and views<br>
      </h2>
      <p>Once you have established connections to Amos II peers you can
        define views of data from your peers. You first have to import
        the meta-data about selected types and functions from the peers.
        This is done by defining <span style="font-style: italic;">proxy




          types</span> and <span style="font-style: italic;">proxy
          functions</span> <a href="#RJK03">[RJK03]</a> using the
        system function <tt>import_types</tt>:<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          import_types(Vector of Charstring typenames,&nbsp; Charstring
          p)-&gt; Bag of Type pt</span><br>
        defines proxy types <span style="font-family: monospace;">pt</span>
        for types named <span style="font-family: monospace;">typenames</span>
        in peer <span style="font-family: monospace;">p</span>. Proxy
        functions are defined for the functions in <span
          style="font-family: monospace;">p</span> having the imported
        types as only argument. Inheritance among defined proxy
        types&nbsp; is imported according to the corresponding&nbsp;
        inheritance relationships between imported types in the peer <span
          style="font-family: monospace;">p</span>. <br>
      </p>
      <p>Once the proxy types and functions are defined they can
        transparently be queried. Proxy types can be references using <span
          style="font-family: monospace;">@</span> notation to reference
        types in other peers.<br>
        For example,<br>
        <span style="font-family: monospace;">&nbsp;&nbsp; select
          name(p) from Person@p1;</span><br style="font-family:
          monospace;">
        selects the <span style="font-family: monospace;">name</span>
        property of objects of type <span style="font-family:
          monospace;">Person</span> in peer <span style="font-family:
          monospace;">p1</span>.<br>
      </p>
      <p><span style="font-family: monospace;">import_types</span>
        imports only those functions having one of <tt>typenames</tt>
        as its single arguments. You can import other functions using
        system function <tt>import_func</tt>:<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;
          import_func(Charstring fn, Charstring p)-&gt;Function pf</span><br>
        imports a function named <span style="font-family: monospace;">fn</span>
        from peer <span style="font-family: monospace;">p</span>
        returning proxy function <span style="font-family: monospace;">pf</span>.<br>
      </p>
      <p>On top of the imported types object-oriented multi-peer views
        can be defined, as described in <a href="#RJK03">[RJK03]</a>
        consisting of <span style="font-style: italic;">derived types</span>
        <a href="#JR99a">[JR99a]</a> whose extents are derived through
        queries intersecting extents of other types, and <span
          style="font-style: italic;">IUTs</span> <a href="#JR99b">[JR99b]</a>
        whose extents reconciles unions of other type extents. Notice
        that the implementation of IUTs is limited. (In particular the
        system flag <span style="font-family: monospace;">latebinding('OR');</span>
        must be set before IUTs can be used and this may cause other
        problems).<br>
      </p>
      <h1><a name="mediatorfns"></a>6 Accessing external systems</h1>
    </span><span style="font-family: Times New Roman;">This chapter
      first describes <span style="font-style: italic;">multi-directional




        foreign functions</span> <a href="amos_users_guide.html#LR92">[LR92]</a>,
      the basis for accessing external systems from Amos II queries. <br>
      The we describe how to query relational databases through Amos II.
    </span><span style="font-family: Times New Roman;">Finally some
      general types and functions used for defining wrappers of external
      sources are described. </span><br>
    <span style="font-family: Times New Roman;"><br>
    </span><span style="font-family: Times New Roman;">Amos II contains
      number of primitives for accessing different external data sources
      by defining <i>wrappers</i> for each kind external sources. A
      wrapper is a software module for making it possible to query an
      external data source using AmosQL. To allow transparent queries,
      wrappers allow specification of different <i>capabilities</i> for
      different kinds of data sources. The capabilities provide hooks to
      define data source specific re-write rules and cost
      models.&nbsp;&nbsp;
      <p>A general wrappers for <a href="#relational">relational
          databases</a> using JDBC is predefined in Amos II. <br>
      </p>
      <h2><a name="foreign-functions"></a>6.1 Foreign and
        multi-directional functions</h2>
      The basis for accessing external systems from Amos II is to define
      <span style="font-style: italic;">foreign functions</span>. A
      foreign function allows subroutines defined in C/C++ <a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#Ris00a">[Ris00a]</a>,
      Lisp <a href="file:///C:/AmosNT/doc/amos_users_guide.html#Ris00a">[Ris00a]</a>
      <a href="file:///C:/AmosNT/doc/amos_users_guide.html#Ris00b">[Ris00b]</a>,
      or Java <a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#ER00">[ER00]</a>
      to be called from Amos II queries. This allows access to external
      databases, storage managers, or computational libraries. A foreign
      function is defined by the following <a href="#fn-implementation">function



        implementation</a>:<br>
      <br>
      <tt><a name="foreign-body"></a>foreign-body ::=
        simple-foreign-definition | multidirectional-definition<br>
        <br>
        <a name="simple-foreign"></a>simple-foreign-body ::= 'foreign' [<a
          href="#string-constant">string-constant</a>] <br>
        <br>
        <a name="multidirectional"></a>multidirectional-definition ::=
        'multidirectional' capability-list<br>
        <br>
        <a name="capability"></a>capability ::= (binding-pattern
        'foreign' </tt><tt><a href="#string-constant">string-constant</a>
      </tt><tt>['cost' cost-spec]['rewriter' </tt><tt><a
          href="#string-constant">string-constant</a></tt><tt>])<br>
        <br>
        <a name="binding-pattern-syntax"></a>binding-pattern ::= </tt>A
      string constant containing </span>'b':s<span style="font-family:
      Times New Roman;"> and </span>'f':s<span style="font-family:
      Times New Roman;"><tt><br>
        <br>
        cost-number ::= <a href="#integer-constant">integer-constant</a>
        | <a href="#real-constant">real-constant<br>
        </a><br>
        cost-spec ::= <a href="#function-name">function-name</a> | '{'
        cost-number ',' cost-number '}'<br>
        <br>
      </tt><span style="font-family: times new roman;">&nbsp; For
        example:</span><tt><br>
        <br>
        &nbsp;&nbsp; create function <a href="#iota">iota</a>(Integer
        l, Integer u) -&gt; Bag of Integer as foreign 'iota--+';<br>
        <a name="sqroots"></a>&nbsp;&nbsp; create function
        sqroots(Number x)-&gt; Bag of Number r<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as multidirectional<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ("bf" foreign
        'sqrts' cost {2,2})<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ("fb" foreign
        'square' cost {1.2,1});<br>
        &nbsp;&nbsp; create function bk_access(Integer handle_id
        )-&gt;(Vector&nbsp; key, Vector) <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Access rows in
        BerkeleyDB table
        */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        &nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as multidirectional <br>
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ('bff' foreign
        'bk_scan' cost bk_cost rewriter 'abkw') <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ('bbf'
        foreign 'bk_get' cost {1002, 1});<br>
        &nbsp;&nbsp; create function myabs(real x)-&gt;real y <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as multidirectional <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("bf"
        foreign "JAVA:Foreign/absbf" cost {2,1})<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("fb"
        foreign "JAVA:Foreign/absfb" cost {4,2});<br>
      </tt><br>
      The syntax using <a href="#multidirectional">multidirectional
        definition</a> provide for specifying different implementations
      of foreign functions depending on what variables are known for a
      call to the function in a query, which is called different <a
        href="#binding-pattern"><span style="font-style: italic;">binding




          patterns</span></a>. The simplified syntax using <a
        href="#simple-foreign">simple-foreign-body</a> is mainly for
      quick implementations of functions without paying attention to
      different implementations based on different binding patterns.<br>
      <br>
      A foreign function can implement one of the following:<br>
      <ol>
        <li>A<span style="font-style: italic;"> filter </span>which is
          a predicate, indicated by a foreign function whose result is
          of type <span style="font-style: italic;">Boolean</span>,
          e.g. '&lt;', that succeeds when certain conditions over its
          results are satisfied.</li>
        <li>A<span style="font-style: italic;"> computation </span>that
          produces a result given that the arguments are known, e.g. +
          or <span style="font-family: monospace;">sqrt</span>. Such a
          function has no argument nor result of type <span
            style="font-style: italic;">Bag</span>.<br>
        </li>
        <li>A<span style="font-style: italic;"> generator </span>that
          has a result of type <span style="font-style: italic;">Bag</span>.
          It produces the result as a bag by generating a stream of
          several&nbsp; result tuples given the argument tuple, e.g. <a
            href="#iota">iota</a> or the function sending SQL statements
          to a relational database for evaluation where the result is a
          bag of tuples.</li>
        <li>An <span style="font-style: italic;">aggregate function</span>
          has some argument of type <span style="font-style: italic;">Bag</span>
          but not result of type <span style="font-style: italic;">Bag</span>.
          It iterates over one or several bag argument to compute some
          aggregate value over the bag, e.g. the <span style="font-style:
            italic;">average</span>.</li>
        <li>A <span style="font-style: italic;">combiner has</span> has
          both one or several arguments of type <span
            style="font-style: italic;">Bag</span> and some result of
          type <span style="font-style: italic;">Bag</span>. It
          combines one or several bags to form a new bag. For example,
          basic join operators can be defined as combiners.<br>
        </li>
      </ol>
      Amos II functions in general are <span style="font-style:
        italic;">multi-directional</span>. A multi-directional function
      can be executed also when the result of a function is given and
      some corresponding argument values are sought. For example, if we
      have a function <br>
      <pre>&nbsp;&nbsp;&nbsp; parents(Person)-&gt; Bag of Person </pre>
      we can ask these AmosQL queries:<br>
      <pre>    parents(:p);&nbsp; /* Result is the bag of parents of :p */<br>    select c from Person c where :p in parents(c);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   /* Result is bag of children of :p */&nbsp;</pre>
      It is often desirable to make <span style="font-style: italic;">foreign</span>
      Amos II functions multi-directional as well. As a very simple
      example, we may wish to ask these queries using the square root
      function <span style="font-family: monospace;">sqroots</span>
      above:<br>
      <pre>    sqroots(4.0);&nbsp;&nbsp;&nbsp; /* Result is -2.0 and 2.0 */ <br>    select x from Number x where sqroots(x)=4.0;<br>&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   /* result is 16.0 *<br>    sqroots(4.0)=2.0;<br>                    /* Is the square root of 4 = 2 */ <br></pre>
      <a name="binding-pattern"></a>With <a href="#simple-foreign">simple
foreign




        functions</a> only the forward (non-inverse) function call is
      possible. Multi-directional foreign functions permit also the
      inverse to be called in queries.<br>
      <br>
      The benefit of multi-directional foreign functions is that a
      larger class of queries calling the function is executable, and
      that the system can make better query optimization. A
      multi-directional foreign function can have several <a
        href="#capability">capabilities</a> implemented depending on the
      <span style="font-style: italic;">binding pattern</span> of its
      arguments and results. The binding pattern is a string of b:s and
      f:s, indicating which arguments or results in a given situation
      are known or unknown, respectively.<br>
      <br>
      For example, the square root (<span style="font-family:
        monospace;">sqroots</span>) actually has the following possible
      binding patterns:<br>
      <br>
      (1) If we know <span style="font-family: monospace;">x</span> but
      not <span style="font-family: monospace;">r</span>, the binding
      pattern is <span style="font-family: monospace;">"bf"</span> and
      the implementation should return <span style="font-family:
        monospace;">r</span> as the square root of <span
        style="font-family: monospace;">x</span>.<br>
      (2) If we know <span style="font-family: monospace;">r</span> but
      not <span style="font-family: monospace;">x</span>, the binding
      pattern in <span style="font-family: monospace;">"fb"</span> and
      the implementation should return <span style="font-family:
        monospace;">x</span> as <span style="font-family: monospace;">r**2</span>.<br>
      (3) If we know both <span style="font-family: monospace;">r</span>
      and <span style="font-family: monospace;">x</span> then the
      binding pattern is <span style="font-family: monospace;">"bb"</span>
      and the implementation should check that <span
        style="font-family: monospace;">x = r**2</span>.<br>
      &nbsp;<br>
      Case (1) and (2) are implemented by multi-directional foreign
      function <span style="font-family: monospace;">sqroots</span>
      above.<br>
      Case (3) need not be implemented as it is inferred by the system
      by first executing <span style="font-family: monospace;">r**2</span>
      and then checking that the result is equal to <span
        style="font-family: monospace;">x</span> (see <a href="#LR92">[LR92]</a>).<br>
      <br>
      To implement a multi-directional foreign function you first need
      to think of which binding patterns require implementations. In the
      <span style="font-style: italic;">sqroots</span> case one
      implementation handles the square root and the other one handles
      the square. The binding patterns will be <span
        style="font-family: monospace;">"bf"</span> for the square root
      and <span style="font-family: monospace;">"fb"</span> for the
      square. <br>
      <br>
      The following steps are required to define a foreign function:<br>
      <ol>
        <li><span style="font-style: italic;">Implement </span>each
          foreign function capability using the interface of the
          implementation language. For Java this is explained in <a
            href="#ER00">[ER00]</a>&nbsp; and for C and Lisp in&nbsp; <a
            href="#Ris00a">[Ris00a]</a>. </li>
        <li>In case the foreign code is statically linked C/C++ the
          implementation must be <span style="font-style: italic;">linked



          </span>to the kernel by making a <span style="font-style:
            italic;">driver</span> program that is referencing it as an
          external function <a href="#Ris00a">[Ris00a]</a>. This is
          needed for foreign functions in C, but not for Java or Lisp
          foreign functions which are dynamically loaded into the
          system.</li>
        <li>Statically linked C/C++ code must also be assigned a <span
            style="font-style: italic;">symbolic name</span> to be
          referenced in the foreign function capability definition (<span
            style="font-family: monospace;">sqrts</span> and <span
            style="font-family: monospace;">square</span> in the
          example) <a href="#Ris00a">[Ris00a]</a>.</li>
        <li>Finally the multidirectional foreign function needs to be <span
            style="font-style: italic;">defined </span>through a
          foreign function definition in AmosQL as <a
            href="#foreign-body">above</a>. Here the implementor may
          associate a binding pattern and an optional <a
            href="#cost-estimate">cost estimate</a> with each
          capability. Normally the foreign function definition is done
          separate from the actual code implementing its capabilities,
          in an AmosQL script.</li>
      </ol>
      A capability can also be defined as a select expression (i.e.
      query) executed for the given binding pattern. The variables
      marked bound (b) are inputs to the select expression and the
      result binds the free (f) variables. For example, <a
        href="#sqroots"><span style="font-family: monospace;">sqroots</span></a>
      could also have been defined by:<br>
      <br>
      <tt>&nbsp;&nbsp; create function sqroots(Number x)-&gt; Bag of
        Number r<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as multidirectional<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ("bf" foreign
        'sqrts' cost {2,2}) /* capability by foreign function */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ("fb" select
        r*r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;




        /* capability by query */<br>
        &nbsp; </tt><br>
      Notice here that <span style="font-style: italic;">sqroots</span>
      is defined as a foreign function when <span style="font-style:
        italic;">x</span> is known and <span style="font-style:
        italic;">r</span> computed, while it is a derived function when
      <span style="font-style: italic;">r</span> is known and <span
        style="font-style: italic;">x</span> computed. This kind of
      functionality is useful when different methods are used for
      computing a function and its inverses.<br>
      <br>
      A capability can be defined as a key to improve query
      optimization, e.g.<br>
      <br>
      <tt>&nbsp;&nbsp; create function sqroots(Number x)-&gt; Bag of
        Number r<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as multidirectional<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ("bf" foreign
        'sqrts' cost {2,2}) /* not unique square root per x */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; ("fb" key
        select
        r*r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* unique square per r */<br>
      </tt><br>
      Be very careful not to declare a binding pattern as key unless it
      really is a key for the arguments and results of the function. In
      the case of <span style="font-style: italic;">sqroots</span> the
      declaration says that if yoo know <span style="font-style:
        italic;">r</span> you can uniquely determine <span
        style="font-style: italic;">x</span>. However, there is no key
      for binding pattern <span style="font-style: italic;">bf</span>
      since if you know <span style="font-style: italic;">x</span>
      there may be severeal (i.e. two) square roots, the positive and
      the negative. The key declarions are used by the system to
      optimize queries. Wrong key declarations may result in wrong query
      results because the optimizer has assumed incorrect key
      uniqueness.<br>
      <br>
      An example of an advanced multidirectional function is the bult-in
      function <span style="font-style: italic;">plus</span> (operator
      +):<br>
    </span><span style="font-family: Times New Roman;"></span>
    <pre>create function plus(Number x, Number y) -&gt; Number r<br>  as multidirectional<br>     ('bbf' key foreign 'plus--+')     /* addition*/<br>     ('bfb' key foreign 'plus-+-')     /* subtraction */<br>     ('fbb' key select x where y+x=r); /* Addition is commutative */<br></pre>
    <span style="font-family: Times New Roman;">For further details on
      how to define multidirectional foreign functions for different
      implementation languages see&nbsp; <a
        href="amos_users_guide.html#Ris00a">[Ris00a]</a>.<br>
      <br>
      <h3><a name="cost-estimate"></a>6.1.1 Cost estimates</h3>
      Different capabilities of multi-directional foreign functions
      often have different execution costs. In the <span
        style="font-family: monospace;">sqroots</span> example the cost
      of computing the square root is higher than the cost of computing
      the square. When there are several alternative implementations of
      a multi-directional foreign function the cost-based query
      optimizer needs cost estimates that help it choose the most
      efficient implementation. In the example we might want to indicate
      that the cost of executing a square root is double as large as the
      cost of executing a square.<br>
      <br>
      Furthermore, the cost of executing a query depends on the expected
      size of the result from a function call. This is called the <span
        style="font-style: italic;">fanout</span> (or <span
        style="font-style: italic;">selectivity</span> for predicates)
      of the call for a given binding pattern. In the multi-directional
      foreign function <a href="#sqroots"><span style="font-family:
          monospace;">sqroots</span></a> example the implementation <span
        style="font-family: monospace;">sqrts</span> usually has a
      fanout of 2, while <span style="font-family: monospace;">square</span>
      has a fanout of 1.<br>
      <br>
      Thus for good query optimization each foreign function capability
      should have associated <span style="font-style: italic;">costs </span>and



      <span style="font-style: italic;">fanouts</span>: <br>
      <ul>
        <li>The <span style="font-style: italic;">cost </span>is an
          estimate of how expensive it is to completely execute (emit
          all tuples of) a foreign function for given arguments. </li>
        <li>The <span style="font-style: italic;">fanout </span>estimates
the




          expected number of elements in the result stream (emitted
          tuples), given the arguments. </li>
      </ul>
      The cost and fanout for a multi-directional foreign function
      implementation can be either specified as a constant <a
        href="#vector">vector</a> of two numbers (as in <tt>sqroots </tt>above)



      or as an Amos II <span style="font-style: italic;">cost function
      </span>returning the vector of cost and fanout for a given
      function call. The numbers normally need only be rough numbers, as
      they are used by the query optimizer to compare the costs of
      different possible execution plans to produce the optimal one. The
      number 1 for the cost of a foreign function should roughly be the
      cost to perform a cheap function call, such as '+' or '&lt;'.
      Notice that these estimates are run a query optimization time, not
      when the query is executed, so the estimates must be based on
      meta-data about the multi-directional foreign function.<br>
      <br>
      If the <a href="#simple-foreign">simplified syntax</a> is used or
      no cost is specified the system tries to put reasonable default
      costs and fanouts on foreign functions, the <span
        style="font-style: italic;">default cost model</span>. The
      default cost model estimates the cost based on the signature of
      the function, index definitions, and some other heuristics. </span><span
      style="font-family: Times New Roman;">For example, the default
      cost model assumes aggregate functions are expensive to execute
      and combiners even more expensive. </span><span
      style="font-family: Times New Roman;">If you have expensive
      foreign functions you are strongly advised to specify cost and
      fanout estimates. <br>
      <br>
      The cost function <span style="font-family: monospace;">cfn</span>
      is an Amos II function with signature<br>
      <pre>create function &lt;cfn&gt;(Function f, Vector bpat, Vector args)&nbsp; <br>                      -&gt; (Integer cost, Integer fanout) as ...;<br>e.g.<br><br>   create function typesofcost(Function f, Vector bpat, Vector args) <br>                               -&gt; (Integer cost, Integer fanout) as foreign ...;<br></pre>
      The cost function is normally called at compile time when the
      optimizer needs the cost and fanout of a function call in some
      query. The arguments and results of the cost function are:<br>
      <br>
      <span style="font-family: monospace;">f</span> &nbsp;
      &nbsp;&nbsp;&nbsp; is the full name the called Amos II function.<br>
      <span style="font-family: monospace;">bpat</span> is the binding
      pattern of the call as a <a href="#vector">vector</a> of strings
      &#8217;b&#8217; and &#8217;f&#8217;, e.g. {"f","b"} indicating which arguments in the call
      are bound or free, respectively.<br>
      <span style="font-family: monospace;">args</span> is a vector of
      actual variable names and constants used in the call.<br>
      cost&nbsp;&nbsp; is the computed estimated cost to execute a call
      to f with the given binding pattern and argument list. The cost to
      access a tuple of a stored function (by hashing) is 2; other costs
      are calibrated accordingly.<br>
      <span style="font-family: monospace;">fanout</span> is the
      estimated fanout of the execution, i.e. how many results are
      emitted from the execution.<br>
      <br>
      If the cost hint function does not return anything it indicates
      that the function is not executable in the given context and the
      optimizer will try some other capability or execution strategy.<br>
      <br>
      The costs and fanouts are normally specified as part of the
      capability specifications for a multi-directional foreign function
      definition, as in the example. The costs can also be specified
      after the definition of a foreign function by using the following
      Amos II system function:<br>
      <pre>   costhint(Charstring fn,Charstring bpat,Vector ch)-&gt;Boolean&nbsp; </pre>
      e.g. <br>
      <pre>   costhint("number.sqroots-&gt;number","bf",{4,2}); <br>   costhint("number.sqroots-&gt;number","fb",{2,1}); <br></pre>
      <span style="font-family: monospace;">fn</span> is the full name
      of the resolvent.<br>
      <span style="font-family: monospace;"> bpat</span> is the binding
      pattern string.<br>
      <span style="font-family: monospace;">ch </span>is a <a
        href="#vector">vector</a> with two numbers where the first
      number is the estimated cost and the second is the estimated
      fanout. <br>
      <br>
      A cost function <span style="font-family: monospace;">cfn</span>
      can be assigned to a capability with:<br>
      <span style="font-family: monospace;">costhint(Charstring fn,
        Charstring bpat, Function cfn)&nbsp; -&gt; Boolean<br>
        <br>
      </span>To find out what cost estimates are associated with a
      function use:<br>
      <tt>&nbsp;&nbsp; costhints(Function r)-&gt; Bag of (Charstring
        bpat, Object q)</tt><br>
      It returns the cost estimates for resolvent r and their associated
      binding patterns.<br>
      <br>
      To obtain the estimated cost of executing an Amos II&nbsp;
      function <span style="font-style: italic;">f</span> for a given
      binding pattern <span style="font-style: italic;">bp</span>, use<br>
      <tt>&nbsp;&nbsp; plan_cost(Function r, Charstring bp)-&gt; (Number
        cost, Numbers fanout)</tt><br>
      <h2><a name="relational"></a> 6.2 The relational database wrapper</h2>
      <p> There is a predefined wrapper for relational databases using
        the JDBC standard Java-based relational database interface. The
        JDBC wrapper is tested with <a
          href="http://www.mysql.com/products/connector/j/">MySQL
          Connector</a>,&nbsp; <a href="http://www.firebirdsql.org/">FireBird's</a>
        InterClient JDBC driver, and Microsoft's SQLServer driver.&nbsp;
      </p>
      <p> An instance of type <tt>Relational</tt> represents a
        relational database and the functions represents the interface
        functions to relational databases. The <tt>Relational</tt>
        wrapper is an <i>abstract </i>wrapper in the sense that it
        does not implement a specific data source and thus has no
        instances. Therefore some of the relational database interface
        functions of type <span style="font-family: monospace;">Relational</span>
        are defined as <a
          href="file:///C:/AmosNT/doc/amos_users_guide.html#abstract-functions"><i>abstract




            functions</i></a>.&nbsp;In the type hierarchy below for the
        abstract <tt>Relational </tt>wrapper there is a specific
        implemented wrapper for JDBC represented by type <span
          style="font-family: monospace;">Jdbc</span>. The type <span
          style="font-family: monospace;">Jdbc</span> has one instance
        for each JDBC data source connected to by the system. The type
        hierarchy is currently: </p>
      <pre>	Datasource<br>	    |<br>	Relational<br>            |<br>	  Jdbc<br></pre>
      <p> </p>
      <p> If some other interface than JDBC (e.g. ODBC) is used for a
        relational database it would require the implementation of a new
        wrapper and subtype to <span style="font-style: italic;">Relational</span>.<br>
        <br>
        The use of abstract functions makes sure that Amos II will use
        the type resolution to look for implementations of these
        functions in any subtype to <tt>Relational</tt>. <br>
      </p>
      <h4><a name="rdb-connect"></a>6.2.1 Connecting<br>
      </h4>
      The instances of relational data sources are created using a <i>connection



        constructor function</i> that loads necessary drivers and
      creates a <span style="font-style: italic;">connection </span>object



      to be assigned to a database using the driver. <br>
      <br>
      <span style="text-decoration: underline;">Creating connections</span><br>
      <br>
      For accessing relational databases using JDBC (the currently only
      supported option) use the constructor:<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp; jdbc(Charstring
        dsname, Charstring driver);<br>
      </span>where <span style="font-family: monospace;">dsname</span>
      is the data source name and <span style="font-family: monospace;">driver</span>
      is the JDBC driver to use for the access. For example, to create a
      connection called 'db1' to access a relational database using JDBC
      with MySQL call:<br>
      <pre>   jdbc("db1","<span style="font-family: monospace;">com.mysql.jdbc.Driver</span>");<br><br></pre>
      <span style="text-decoration: underline;">Connecting to the
        database</span><br>
      <br>
      Once the connection object has been created you can open the
      connection to a specific relational database:<br>
      <pre>   connect(Relational r, Charstring database, Charstring username, Charstring password) -&gt; Relational</pre>
      where <span style="font-style: italic;">r</span> is the
      connection object, <span style="font-style: italic;">db</span> is
      the identifier of the database to access, along with user name and
      password to use when accessing the database. For example, if the
      relational database called 'Personnel' resides on the local
      computer and MySQL is used for the managing it, the following
      opens a connection to the database for user 'U1' with password
      'PW': <br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp; connect(:db,
        "jdbc:mysql://localhost:3306/Personnel", "U1", "PW");</span><br>
      <br>
      <span style="text-decoration: underline;">Disconnecting from the
        database</span><br>
      <br>
      Once the connection is open you can use the connection object for
      various database manipulations. The connection is closed with:<br>
      <pre>   disconnect(Relational r) -&gt; Boolean</pre>
      for example:<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp; disconnect(:a):<br>
      </span><br>
      <span style="text-decoration: underline;">Finding a named
        connection</span><br>
      <br>
      To get the connection object given its name use:<br>
      <br>
      <pre>   relational_named(Charstring nm)-&gt; Relational</pre>
      for example:<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp;
        relational_named("db1");</span><br>
      <h4><a name="rdb-metadata"></a>6.2.2 Accessing meta-data<br>
      </h4>
      Relational meta-data are general information about the tables
      stored in a relational database.<br>
      <br>
      <span style="text-decoration: underline;">Tables in database</span><br>
      <br>
      To find out what tables there are in a relational database, use<br>
      <pre>   tables(Relational r) <br>       -&gt; Bag of (Charstring table, Charstring catalog, <br>                  Charstring schema, Charstring owner)</pre>
      for example
      <pre>    tables(relational_named("db1"));<br></pre>
      The function <tt>tables</tt> returns a bag of tuples describing
      the tables stored in the relational database.<br>
      <br>
      <br>
      To test whether a table is present in a database use:<br>
      <pre>    has_table(Relational r, Charstring table_name) -&gt; Boolean<br></pre>
      for example<br>
      <pre>    has_table(relational_named("db1"),"SALES");</pre>
      <br>
      <span style="text-decoration: underline;">Columns in table</span><br>
      <br>
      To get a description of the columns in a table use:<br>
      <pre>    columns(Relational r, Charstring table_name) <br>        -&gt; Bag  of (Charstring column_name, Charstring column_type)</pre>
      for example<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
        columns(relational_named("db1"),"CUSTOMER");<br>
        <br>
      </span><span style="text-decoration: underline;">Size of table</span><br>
      <br>
      To find out how many rows there are in a table use:<br>
      <pre>     cardinality(Relational r, Charstring table_name) -&gt; Integer</pre>
      <br>
      for example<br>
      <pre>     cardinality(relational_named("db1"),"SALES");</pre>
      <br>
      <span style="text-decoration: underline;">Primary keys of table</span><br>
      <br>
      To get a description of the primary keys of a table use:<br>
      <pre>    primary_keys(relational r, charstring table_name) <br>             -&gt; Bag of (charstring  column_name, charstring constraint_name)</pre>
      for example:<br>
      <pre>     primary_keys(relational_named("db1"),"CUSTOMER");<br></pre>
      <br>
      <span style="text-decoration: underline;">Foreign keys of table</span><br>
      <br>
      To get information about the foreign keys referenced from a table
      use:<br>
      <pre>     imported_keys(Jdbc j, Charstring fktable) <br>               -&gt; Bag of (Charstring pktable, Charstring pkcolumn, Charstring fkcolumn)</pre>
      for example<br>
      <pre>     imported_keys(relational_named("db1"),"PERSON_TELEPHONES");</pre>
      The elements of the result tuples denote the following:<br>
      <ul>
        <li><code>pktable</code> - The table referenced by the foreign
          key. </li>
        <li><code>pkcolumn</code> - The column referenced by the foreign
          key. </li>
        <li><code>fkcolumn</code> - The foreign key column in the table.
        </li>
      </ul>
      <span style="font-weight: bold;">NOTICE</span> that composite
      foreign keys are not supported.<br>
      <br>
      &nbsp;<br>
      To find what keys in a table are exported as foreign keys to some
      other table use:<br>
      <pre>     exported_keys(Jdbc j, Charstring pktable) <br>               -&gt; Bag of (Charstring pkcolumn, Charstring fktable, Charstring fkcolumn)</pre>
      for example<br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
        exported_keys(relational_named("db1"),"PERSON");</span><br>
      <br>
      The elements of the result tuples denote the following:<br>
      <ul>
        <li><code>pkcolumn</code> - The primary key column in the table.
        </li>
        <li><code>fktable</code> - The table whose foreign key
          references the table. </li>
        <li><code>fkcolumn</code> - The foreign key column in the table
          that references the table.</li>
      </ul>
      <span style="text-decoration: underline;">Deleting tables</span><br>
      <br>
      The function drop_table deletes a table from a wrapped relational
      database:<br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
        &nbsp;&nbsp;&nbsp; drop_table(Relational r, Charstring name)
        -&gt; Integer</span><br>
      <span style="font-family: monospace;"></span>
      <h4><a name="rdb-SQL"></a>6.2.3 Executing SQL</h4>
      <p><span style="text-decoration: underline;">SQL statements</span><br>
        <br>
        The function <span style="font-family: monospace;">sql</span>
        executes an arbitrary SQL statement as a string:</p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
          sql(Relational r, Charstring query) -&gt; Bag of Vector
          results</span><br>
      </p>
      <p>The result is a bag of results tuples represented as <a
          href="#vector">vectors</a>. If the SQL statement is an update
        a single tuple containing one number is returned, being the
        number of rows affected by the update. Example:<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
          sql(relational_named("db1"), "select NAME from PERSON where
          INCOME &gt; 1000 and AGE&gt;50");<br>
          <br>
        </span> </p>
      <p><span style="text-decoration: underline;">Parameterized SQL
          statements</span><br>
      </p>
      <p>To execute the same SQL statement with different parameters
        use:<br>
      </p>
      <p><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
          sql(Relational r, Charstring query, Vector params) -&gt; Bag
          of Vector results</span><br>
      </p>
      <p>The parameters in <span style="font-family: monospace;">params</span>
        are substituted into the corresponding occurrences in the SQL
        statement, for example:<br>
      </p>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
        sql(relational_named("db1"), "select NAME from PERSON where
        INCOME &gt; ? and AGE&gt;?", {1000,50));<br>
        <br>
      </span><br>
      <span style="text-decoration: underline;">Loading SQL scripts</span><br>
      <br>
      SQL statements in a file separated with ';' can be loaded with:<br>
      <br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
        read_sql(Relational r, Charstring filename) -&gt; Bag of Vector</span><br>
      <br>
      The result from </span><span style="font-family: monospace;">read_sql</span><span
      style="font-family: Times New Roman;"> is a bag containing the
      result tuples from executing the read SQL statements.<br>
      <br>
      Hint: If something is wrong in the script you may with to trace
      the calls from </span><span style="font-family: monospace;">read_sql




    </span><span style="font-family: Times New Roman;">to function </span><span
      style="font-family: monospace;">sql</span><span
      style="font-family: Times New Roman;"> by calling <br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
        trace("sql");</span><br>
      <span style="font-family: monospace;"></span>
      <h4><a name="rdb-ooview"></a>6.2.4 Object-oriented view of tables</h4>
      The relational wrapper allows to to define object-oriented views
      of data residing in a relational database. Once the view has been
      defined the contents of the database can be used in AmosQL queries
      without any explicit calls to SQL.<br>
      <br>
      To regard a relational table as an Amos II type use:<br>
      <pre>    import_table(Relational r, Charstring table_name) -&gt; Mapped_type</pre>
      for example
      <pre>    import_table(relational_named("db1"),"SALES");</pre>
      The view is represented by a <a
        href="file:///C:/AmosNT/doc/amos_users_guide.html#mapped"><i>mapped




          type</i></a> which is a type whose extent is defined by the
      rows of the table. Each instance of the mapped type corresponds to
      a row in the table. The name of the mapped type is constructed by
      concatenating the table name, the character <tt>_</tt> and the
      data source name, for example <tt>Person_db1</tt>. Mapped type
      names are internally capitalized, as for other Amos II types.<br>
      <p> For each columns in the table <tt>import_table</tt> will
        generate a corresponding derived <i>wrapper function</i>
        returning the column's value given an instance of the mapped
        type. For example, a table named <code>person</code> having the
        column <code>ssn</code> will have a function </p>
      <ul>
        <pre> ssn(Person_db1)-&gt;Integer </pre>
      </ul>
      returning the <tt>ssn</tt> of a person from the imported
      relational table.<br>
      <br>
      <br>
      The system also allows wrapped relational tables to be
      transparently updated using an <a href="#updates">update
        statement</a> by importing the table with:<br>
      <pre>      import_table(Relational r, <br>                   Charstring table_name, <br>                   Boolean updatable)<br>               -&gt; Mappedtype mt</pre>
      for example<br>
      <pre>      import_table(relational_named("db1"),"COUNTRY",true);</pre>
      If the flag <span style="font-style: italic;">updatable</span> is
      set to true the functions in the view are transparently updatable
      so the relational database is updated when instances of the mapped
      type are created or the extent of some wrapper function
      updated.&nbsp; For example:<br>
      <pre>      create Country_db1(currency,country) instances ("Yen","Japan");<br>      set currency(c)= "Yen" from Country_db1 c where country(c)= "Japan";<br></pre>
      <p><br>
        The most general resolvent of<tt> import_table</tt> is:<br>
      </p>
      <pre>      import_table(Relational r, Charstring catalog_name,<br>                   Charstring schema_name, Charstring table_name,<br>                   Charstring typename, Boolean updatable,<br>                   Vector supertypes) -&gt; Mappedtype mt</pre>
      <p>The table resides in the given catalog and schema. If catalog
        is "", the table is assumed not to be in a catalog. If schema is
        "", the table is assumed not to be in a schema. <code>typename</code>
        is the desired name of the mapped type created, as alternative
        to the system generated concatenation of table and data source
        name. <code>updatable</code> gives an updatable mapped type. <code>supertypes</code>
        is a <a href="#vector">vector</a> of either type names or type
        objects, or a mixture of both. The effect is that Amos II will
        perceive the mapped type as an immediate subtype of the types.<br>
      </p>
      <br>
      There are also two other variants of </span><span
      style="font-family: monospace;">import_table</span><span
      style="font-family: Times New Roman;"> to be used for relational
      databases where schema and catalog names need not be specified:<br>
      <pre>      import_table(Relational r, <br>                   Charstring table_name, <br>                   Charstring typename, <br>                   Boolean updatable,<br>                   Vector supertypes) -&gt; Mappedtype mt</pre>
      <pre>      import_table(Relational r,<br>                   Charstring table_name, <br>                   Charstring type_name, <br>                   Boolean updatable) -&gt; Mappedtype mt<br><br></pre>
      <span style="font-family: monospace;"></span>
      <ul>
      </ul>
      <p> </p>
      <h4>6.2.4.1 Importing many-to-many relationships</h4>
      <p> All tables in relational databases do not correspond to
        'entities' in an ER diagram and therefore cannot be directly
        mapped to types. The most common case is tables representing
        many-to-many relationships between entities. Typically such
        tables have two columns, each of which is a foreign key imported
        from two other tables, expressing the many-to-many relationship
        between the two. Only entities are imported as types and special
        types are not generated for such relationship tables. A
        many-to-many relationship in a relational database corresponds
        to a function returning a <i>bag</i> in AmosQL, and can be
        imported using <code>import_relation</code> rather than <code>import_table</code>:
      </p>
      <ul>
        <li>
          <pre>import_relation(Relational r,<br>                Charstring table_name, Charstring argument_column_name, <br>                Charstring result_column_name, Charstring function_name, <br>                Boolean updatable)<br>            -&gt; Function<br></pre>
        </li>
        <ul>
          <li><code>table_name</code> - the name of the table containing
            the relation.</li>
          <li><code>argument_column_name</code> - the name of the column
            which is argument of the function.</li>
          <li><code>result_column_name</code> - the name of the column
            which is result of the function.</li>
          <li><code>function_name</code> - the desired name of the
            function.</li>
          <li><code>updatable</code> - whether the function should be
            transparently updatable via <code>set</code>, <code>add</code>,
            and <code>remove</code>.</li>
        </ul>
      </ul>
      <p> For example, assume we have two entities, <code>person</code>
        and <code>telephone</code>. Most of the time telephones are not
        regarded as entities in their own respect since nobody would
        care to know more about a telephone than its number. However,
        assume that also the physical location of the telephone is kept
        in the database, so telephones are an entity type of their own.
      </p>
      <p> A person can be reached through several telephones, and every
        telephone may be answered by several person. The schema looks as
        follows: </p>
      <center>
        <table rules="group" align="top" border="1" cellpadding="0"
          cellspacing="0">
          <caption><code>person</code></caption> <tbody>
            <tr>
              <td><ins><code>ssn</code></ins></td>
              <td><abbr><code>name</code></abbr></td>
              <td><code>...</code></td>
            </tr>
            <tr>
              <td> <br>
              </td>
              <td> <br>
              </td>
              <td> <br>
              </td>
            </tr>
          </tbody>
        </table>
        <table rules="group" border="1" cellpadding="0" cellspacing="0">
          <caption><code>person_telephones</code></caption> <tbody>
            <tr>
              <td><abbr><code>ssn</code></abbr></td>
              <td><abbr><code>ext_no</code></abbr></td>
            </tr>
            <tr>
              <td> <br>
              </td>
              <td> <br>
              </td>
              <td> <br>
              </td>
            </tr>
          </tbody>
        </table>
        <table rules="group" border="1" cellpadding="0" cellspacing="0">
          <caption><code>telephone</code></caption> <tbody>
            <tr>
              <td><abbr><code>ext_no</code></abbr></td>
              <td><abbr><code>location</code></abbr></td>
              <td><code>...</code></td>
            </tr>
            <tr>
              <td> <br>
              </td>
              <td> <br>
              </td>
              <td> <br>
              </td>
            </tr>
          </tbody>
        </table>
      </center>
      Now, this schema can be wrapped by the following commands:
      <ol>
        <li><code>import_table(my_relational, 'person');</code> </li>
        <li><code>import_table(my_relational, 'telephone');</code> </li>
        <li><code>import_relation(my_relational, 'telephone',
            'ssn','ext_no','phones', false);</code><br>
        </li>
        <li><code>create function phones(person@my_relational p) -&gt;
            telephone@my_relational t as select t where phones(ssn(p)) =
            ext_no(t);</code><br>
        </li>
      </ol>
      <p> Notice that only relationship functions with a single argument
        and result can be generated, i.e. composite foreign keys are not
        supported.<br>
      </p>
    </span><span style="font-family: Times New Roman;">
      <h2><a name="generic_wrapper"></a>6.3 Defining new wrappers<br>
      </h2>
      Wrappers make data sources queryable. Some wrapper functionality
      is completely data source independent while other functionality is
      specific for a particular kind of data source. Therefore, to share
      wrapper functionality Amos II contains a type hierarchy of
      wrappers. In this section we describe common functionality used
      for defining any kind of wrapper.<br>
      <a name="data-sources"></a>
      <h3>6.3.1 Data sources</h3>
      Types and objects of type <tt>Datasource</tt> describe properties
      of different kinds of data sources accessible through Amos II.
      Each kind of wrapped data source has a corresponding data source <i>type</i>,
      for example type <i>Amos</i>, <i>Relational</i>, or <i>Jdbc</i>
      to describe Amos II peers, relational databases, or relational
      data bases accessed through JDBC, respectively. These types are
      all subtypes of type <tt>Datasource</tt>. Each <i>instance</i>
      of a data source type represents a particular data source of that
      kind, e.g. a particular relational database accessed trough JDBC
      are instances of type <tt>Jdbc</tt>. <br>
      <a name="mapped"></a><br>
      <h3>6.3.2 Mapped types</h3>
      A <i>mapped type</i> is a type whose instances are identified by
      a key consisting of one or several other objects <a
        href="amos_users_guide.html#FR97">[FR97]</a>. Mapped types are
      needed when proxy objects corresponding to external values from
      some data source are created in a peer. For example, a wrapped
      relational database may have a table PERSON(SSN,NAME,AGE) where
      SSN is the key. One may then wish to define a mapped type named <tt>Pers</tt>
      in the mediator representing proxy objects for the persons in the
      table. The instances of the proxy objects are identified by an
      SSN. The type <tt>Pers</tt> should furthermore have the following
      property functions derived from the contents of the wrapped table
      PERSON:<br>
      <tt>&nbsp; &nbsp;&nbsp; ssn(Pers)-&gt;Integer<br>
        &nbsp; &nbsp;&nbsp; name(Pers)-&gt;Charstring<br>
        &nbsp; &nbsp; &nbsp;age(Pers)-&gt;Integer</tt><br>
      <br>
      The instances and primary properties of a mapped type are defined
      through a <i>Core Cluster Function</i> that returns these as a
      set of tuples, one for each instance. In our example the core
      cluster function should return tuples of three elements <span
        style="font-family: monospace;">(ssn,name,age)</span>. The <a
        href="amos_users_guide.html#relational">relational database
        wrapper</a> will automatically generate such a core cluster
      function for table PERSON (type <tt>Pers</tt>) with signature: <br>
      <tt>&nbsp; &nbsp;pers_cc()-&gt;Bag of (Integer ssn, Charstring
        name, Integer age) as ...</tt><br>
      <br>
      A mapped type is defined through a system function with signature:<br>
      <tt>&nbsp; &nbsp;create_mapped_type(Charstring name, Vector keys,
        Vector attrs, Charstring ccfn)-&gt; Mappedtype</tt><br>
      where <br>
      &nbsp; &nbsp;<tt>name</tt> is the name of the mapped type<br>
      &nbsp; &nbsp;<tt>keys</tt> is a <a
        href="amos_users_guide.html#vector">vector</a> of the names of
      the keys identifying each instance of the mapped type.<br>
      &nbsp; &nbsp;<tt>attrs</tt> is a vector of the names of the
      properties of the mapped type.<br>
      &nbsp; &nbsp;<tt>ccfn</tt> is the name of the core cluster
      function.<br>
      <br>
      In our example the relational database wrapper will automatically
      define the mapped type <tt>Pers</tt> through this call:<br>
      <tt>&nbsp;
&nbsp;create_mapped_type("Pers",{"ssn"},{"ssn","name","age"},"pers_cc");</tt><br>
      <br>
      Notice that the implementor of a mapped type must guarantee key
      uniqueness. <br>
      <br>
      Once the mapped type is defined it can be queried as any other
      type, e.g.:<br>
      <tt>&nbsp; &nbsp;select name(p) from Pers p where age(p)&gt;45;</tt><br>
      <br>
      <h3><a name="type-translation"></a>6.3.3 Type translation</h3>
      Types in a specific data source are translated to corresponding
      types in the mediator using the following system functions:
      <ul>
        <li>
          <pre>amos_type(Datasource ds, Charstring native_type_name) -&gt; Type;<br></pre>
        </li>
        for example
        <pre>amos_type(relational_named("IBDS"),"VARCHAR");<br></pre>
        <tt>amos_type</tt> returns the Amos II type corresponding to the
        a specific data source.
      </ul>
      <ul>
        <li>
          <pre>wrapped_type(Datasource ds, Type t) -&gt; Charstring typename;<br></pre>
        </li>
        for example
        <pre>wrapped_type(relational_named("IBDS"),typenamed("CHARSTRING"));<br></pre>
        returns the data source type corresponding to an Amos II type.
        Since one external type may correspond to more than one Amos II
        type <tt>wrapped_type</tt> is not the inverse of <tt>amos_type</tt>.&nbsp;




      </ul>
      The most common relational types and their Amos II counterparts
      are provided by default. Both functions are stored functions that
      can be updated as desired for future wrappers.</span><span
      style="font-family: Times New Roman;">
      <h1>7 Physical database design</h1>
      This section describes some AmosQL commands for database space and
      performance tuning.&nbsp;
      <h2><a name="indexing"></a> 7.1 Indexing</h2>
      The system supports indexing on any single argument or result of a
      stored function. Indexes can be <i>unique</i> or <i>non-unique</i>.
      A unique index disallows storing different values for the indexed
      argument or result. The cardinality constraint 'key' of stored
      functions (<a href="#cardinality-constraints">Cardinality
        Constraints</a>) is implemented as unique indexes. Thus by
      default the system puts a unique index on the first argument of
      stored functions. That index can be made non-unique by suffixing
      the first argument declaration with the keyword 'nonkey' or to
      specify 'Bag of' for the result, in which case a non-unique index
      is used instead.
      <p>For example, in the following function there can be only one
        name per person: </p>
      <pre>      create function name(Person)-&gt;Charstring as stored;</pre>
      By contrast, <tt>names</tt> allow more than one name per
      person:&nbsp;
      <pre>      create function names(Person p)-&gt;Bag of Charstring nm as stored;</pre>
      Any other argument or result declaration can be suffixed with the
      keyword <tt>'key'</tt> to indicate the position of a unique
      index. For example, the following definition puts a unique index
      on <tt>nm</tt> to prohibit two persons to have the same name:
      <pre>      create function name(Person p)-&gt;Charstring nm key as stored;</pre>
      Indexes can also be explicitly created on any argument or result
      with a procedural system function <tt>create_index</tt>:
      <pre>      create_index(Charstring function, Charstring argname, Charstring index_type,<br>                   Charstring uniqueness)</pre>
      For example:
      <pre>      create_index("person.name-&gt;charstring", "nm", "hash", "unique");<br>      create_index("names", "charstring", "mbtree", "multiple");</pre>
      The parameters of <tt>create_index</tt> are:
      <p> <tt>function</tt>: The name of a stored function. Use the
        resolvent name for <a href="#overloaded-functions">overloaded</a>
        functions.</p>
      <p> <tt>argname</tt>: The name of the argument/result parameter
        to be indexed. When unambiguous, the names of types of
        arguments/results can also be used here.</p>
      <p> <tt>index_type</tt>: Type kind of index to put on the
        argument/result. The supported index types are currently hash
        indexes (type <tt>hash</tt>) and ordered B-tree indexes (type <tt>mbtree</tt>).




        The default index for key/nonkey declarations is <tt>hash</tt>.</p>
      <p> <tt>uniqueness</tt>: Index uniqueness indicated by <span
          style="font-style: italic;">unique</span> for unique indexes
        and <span style="font-style: italic;">multiple</span> for
        non-unique indexes. </p>
      <p>Indexes are deleted by the procedural system function: </p>
      <pre>      drop_index(Charstring functioname, Charstring argname); </pre>
      The meaning of the parameters are as for function <tt>create_index</tt>.
      There must always be at least one index left on each stored
      function and therefore the system will never delete the last
      remaining index on a stored function.
      <p>To save space it is possible to delete the default index on the
        first argument of a stored function. For example, the following
        stored function maps parts to unique identifiers through a
        unique hash index on the identifier: </p>
      <pre>      create type Part;&nbsp;<br>      create function partid(Part p)-&gt;Integer id as stored;</pre>
      <tt>partid</tt> will have two indexes, one on <tt>p</tt> and one
      on <tt>id</tt>. To drop the index on <tt>p</tt>, do the
      following:
      <pre>      drop_index('partid', 'p');</pre>
      <a name="62005"></a>
      <h2> 7.2 Clustering</h2>
      Functions can be <i>clustered</i> by creating multiple result
      stored functions, and then each individual function can be defined
      as a derived function.&nbsp;
      <p>For example, to cluster the properties name and address of
        persons one can define:&nbsp;&nbsp;</p>
      <pre>create function personprops(Person p) -&gt;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Charstring name,Charstring address) as stored;&nbsp;<br>create function name(Person p) -&gt; Charstring nm&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as select nm from Charstring a&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where personprops(p) = (nm,a);&nbsp;<br>create function address(Person p) -&gt; Charstring a&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as select a from Charstring nm&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where personprops(p) = (nm,a);</pre>
      Clustering does not improve the execution time performance
      significantly in a main-memory DBMS such as Amos II. However,
      clustering can decrease the database size considerably.&nbsp; <br>
      <a name="62031"></a>
      <h1>8 System functions and commands</h1>
      <a name="62035"></a>
      <h2> 8.1 Comparison operators<br>
      </h2>
      <a name="62037"></a>The built-in, infix comparison operators
      are:&nbsp;
      <p><a name="62039"></a> </p>
      <pre>=(Object x, Object y) -&gt; Boolean&nbsp;&nbsp; (infix operator =)<br>!=(Object x, Object y) -&gt; Boolean&nbsp; (infix operator !=)&nbsp;<br>&gt;(Object x, Object y) -&gt; Boolean&nbsp;&nbsp; (infix operator &gt;)&nbsp;<br>&gt;=(Object x,Object y) -&gt; Boolean&nbsp;&nbsp; (infix operator &gt;=)<br>&lt;(Object x, Object y) -&gt; Boolean&nbsp;&nbsp; (infix operator &lt;)&nbsp;<br>&lt;=(Object x,Object y) -&gt; Boolean&nbsp;&nbsp; (infix operator &lt;=)</pre>
      All objects can be compared. Strings are compared by characters,
      lists by elements, OIDs by identifier numbers. Equality between a
      bag and another object denotes set membership of that object. The
      comparison functions can, of course, be <a
        href="#overloaded-functions">overloaded</a> for user defined
      types.&nbsp;
      <p><a name="62053"></a> </p>
      <h2> 8.2 Arithmetic functions</h2>
      <pre>abs(Number x) -&gt; Number y<br>div(Number x, Number y)&nbsp;&nbsp; -&gt; Number z         Infix operator /<br>max(Object x, Object y)&nbsp;&nbsp; -&gt; Object z&nbsp;<br>min(Object x, Object y)&nbsp;&nbsp; -&gt; Object z&nbsp;<br>minus(Number x, Number y) -&gt; Number z         Infix operator -&nbsp;<br>mod(Number x, Number y) -&gt; Number z<br>plus(Number x, Number y)&nbsp; -&gt; Number z         Infix operator +<br>times(Number x, Number y) -&gt; Number z         Infix operator *&nbsp;<br>power(Number x, Number y) -&gt; Number z         Infix operator ^&nbsp;<br><span style="font-family: Times New Roman;"><tt><a name="iota"></a></tt></span>iota(Integer l, Integer u)-&gt; Bag of Integer z <br>sqrt(Number x) -&gt; Number z<br>integer(Number x) -&gt; Integer i                Round <span style="font-style: italic;">x</span> to nearest integer<br>real(Number x) -&gt; Real r                      Convert x to real number<br>roundto(Number x, Integer d) -&gt; Number        Round <span style="font-style: italic;">x</span> to <span style="font-style: italic;">d</span> decimals<br>log10(Number x) -&gt; Real y<br></pre>
      <tt>iota</tt> constructs a bag of integers between <span
        style="font-style: italic;">l</span> and <span
        style="font-style: italic;">u</span>.&nbsp; <br>
      For example, to execute n times AmosQL statement 'print(1)'
      do:&nbsp;
      <pre>for each Integer i where i in iota(1,n)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(1);</pre>
      <p><a name="STRING"></a> </p>
      <h2> 8.3 String functions</h2>
      String concatenation is made using the '+' operator, e.g. <br>
      <tt>"ab" + "cd" + "ef";</tt>&nbsp; returns <tt>"abcdef"<br>
        "ab"+12+"de"; </tt>returns <tt>"ab12de"<br>
        1+2+"ab"; </tt>is illegal since the first argument of '+' must
      be a string.<tt><br>
        "ab"+1+2; </tt>returns <tt>"ab12"</tt> since '+' is left
      associative.<br>
      <br>
      <tt>char_length(Charstring)-&gt;Integer</tt><br>
      Count number of characters in string.<br>
      <br>
      <tt>lower(Charstring)-&gt;Charstring</tt><br>
      Lowercase string.<br>
      <br>
      <tt>like(Charstring string, Charstring pattern) -&gt; Boolean</tt><br>
      Test if string matches regular expression pattern where '*'
      matches sequence of characters and '?' matches single character.
      For example:<br>
      <tt>like("abc","??c")</tt> returns TRUE<br>
      <tt>like("ac","a*c")</tt> returns TRUE<br>
      <tt>like("ac","a?c")</tt> fails<br>
      <tt>like("abc","a[bd][dc]");</tt> returns TRUE<br>
      <tt>like("abc","a[bd][de]");</tt> fails <br>
      <br>
      <tt>like_i(Charstring string, Charstring pattern) -&gt; Boolean</tt><br>
      Case insensitive <tt>like.</tt><br>
      <br>
      <span style="font-family: monospace;">stringify(Object
        x)-&gt;Charstring s</span><br>
      Convert any object <span style="font-style: italic;">x</span>
      into a string.<br>
      <br>
      <span style="font-family: monospace;">unstringify(Charstring s)
        -&gt; Object x</span><br>
      Convert string s to object <span style="font-style: italic;">x</span>.
      Inverse of <span style="font-style: italic;">stringify</span>.<br>
      <br>
      <tt>substring(Charstring string,Integer start, Integer
        end)-&gt;Charstring</tt><br>
      Extract substring from given character positions. First character
      has position 0.<br>
      <br>
      <tt>upper(Charstring s)-&gt;Charstring</tt><br>
      Uppercase string <span style="font-style: italic;">s</span>.<br>
      <br>
      <span style="font-family: monospace;">lower(Charstring s) -&gt;
        Charstring</span><br>
      Lowercase string <span style="font-style: italic;">s</span>.<br>
      <br>
      <span style="font-family: monospace;">not_empty(Charstring s)
        -&gt; Boolean</span><br>
      Returns true if string <span style="font-style: italic;">s</span>
      contains only whitespace characters (space, tab, or new line).<br>
      <br>
      <a name="62087"></a>

<h2>8.4 Aggregate functions</h2>

Some of these system functions are also described in <a
href="#subqueries">Subqueries and Aggregate functions</a>.
<br>
<br>
The overloaded function in() implement the infix operator 'in'. It
extracts each element from a collection:

<pre>in(Bag of Object b) -&gt; Bag
in(Vector v) -&gt; Bag</pre>
For example:
<pre>in({1,2,2}); =>
1
2
2
</pre>
<br>
Number of objects in a bag:&nbsp;
<pre>count(Bag of Object b) -&gt; Integer</pre>
For example:
<pre>count(iota(1,100000)); =>
100000
</pre>
<br>
Sum elements in bags of numbers:
<pre>sum(Bag of Number b) -&gt; Number&nbsp;</pre>
For example:
<pre>sum(iota(1,100000)); =>
705082704
</pre>
<br>
Average value in a bag of numbers:<br>
<pre>avg(Bag of Number b) -&gt; Real</pre>
For example:
<pre>avg(iota(1,100000)); =>
50000.5
</pre>
<br>
Standard deviation of values in a bag of numbers:<br>
<pre>stdev(Bag of Number b) -&gt; Real</pre>
For example:
<pre>stdev(iota(1,100000)); =>
28867.6577966877
</pre>
<br>
Largest object in a bag:&nbsp;
<pre>maxagg(Bag of TP b) -&gt; TP y<br></pre>
The type of the result is the same as the type of elements of argument
bag. For example:
<pre>maxagg(bag(3,4,2))+2; =>
6
</pre>
<br>
Smallest number in a bag:&nbsp;
<pre>minagg(Bag of TP b) -&gt; TP y</pre>
The type of the result is the same as the type of elements of argument
bag. For example:
<pre>minagg(bag(3,4,2))+2; =>
4
</pre>
<br>
Test if a bag is empty. Logical NOT EXISTS:&nbsp;
<pre>notany(Bag of Object b) -&gt; Boolean b</pre>
For example:
<pre>notany(bag()); =>
TRUE

notany(select n from number n where n>5 and n in {1,2,3});
TRUE
</pre>
<br>
Test if there are any elements in a bag. Logical EXISTS:&nbsp;
<pre>some(Bag of Object b) -&gt; Boolean b</pre>
For example:
<pre>some(iota(1,1000000)); =>
TRUE

some(select n from number n where n in {1,2,3} and n < 10); =>
TRUE
</pre>
<br>
Remove duplicates from a bag:
<pre>unique(Bag of TP b) -&gt; Bag of TP r</pre> 
The type of the result bag is the same as the type of elements of
argument bag. For example:
<pre>unique(bag(1,2,1,4)); =>
1 
2 
4
</pre>
<br>
Extract non-duplicated elements from a bag:&nbsp;
<pre>exclusive(Bag of TP b) -&gt; Bag of TP r</pre>
The type of the result bag is the same as the type of elements of
argument bag. For example:
<pre>exclusive(bag(1,2,1,4)); =>
2
4
</pre>
<br>
Insert <tt>x</tt> between elements in a bag <tt>b</tt>:
<pre>inject(Bag of Object b, Object x) -&gt; Bag of Object r</pre>
For example:
<pre>inject(bag(1,2,3),0); =>
1
0
2
0
3
</pre>
<br>
Make a string of elements in a bag <tt style="font-style: italic;">b</tt>:
<pre>concatagg(Bag of Object b)-&gt; Charstring s</pre>
For example:
<pre>concatagg(bag("ab",2,"cd")); =>
"ab2cd"

concatagg(inject(bag("ab",2,"cd"),",")); =>
"ab,2,cd"</pre>
<br>

<a name="TEMPORAL"></a>
      <h2> 8.5 Temporal functions</h2>
      Amos II supports three data types for referencing <i>Time,
        Timeval,</i> and <i>Date</i>.<br>
      Type <i>Timeval</i>&nbsp; is for specifying absolute time points
      including year, month, and time-of-day.<br>
      The type <i>Date </i>specifies just year and date, and type <i>Time</i>
      specifies time of day. A limitation is that the internal operating
      system representation is used for representing <i>Timeval </i>values,
which




      means that one cannot specify value too far in the past or future.<br>
      <br>
      <a name="timestamp"></a>Constants of type <i>Timeval</i> are
      written as |<i>year-month-day</i>/<i>hour:minute</i>:<i>second</i>|,
e.g.




      |1995-11-15/12:51:32|.<br>
      Constants of type <i>Time </i>are written as |<i>hour</i>:<i>minute</i>:<i>second</i>|,




      e.g. |12:51:32|.<br>
      Constants of type <i>Date</i> are written as |<i>year</i>-<i>month</i>-<i>day</i>|,




      e.g. |1995-11-15|.<br>
      <br>
      The following functions exist for types <i>Timeval, Time, </i>and




      <i>Date</i>:<br>
      <br>
      <tt>now() -&gt; Timeval</tt><br>
      The current absolute time.<br>
      <br>
      <tt>time() -&gt; Time<br>
      </tt>The current time-of-day.<br>
      <br>
      <span style="font-family: monospace;">clock() -&gt; Real</span><br>
      The number of seconds since the system was started.<br>
      <br>
      <tt>date() -&gt; Date</tt><br>
      The current year and date.<br>
      <br>
      <tt>timeval(Integer year,Integer month,Integer day,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; Integer hour,Integer minute,Integer
        second) -&gt; Timeval</tt><br>
      Construct <i>Timeval.</i><br>
      <br>
      <tt>time(Integer hour,Integer minute,Integer second) -&gt; Time</tt><br>
      Construct <i>Time.</i><br>
      <br>
      <tt>date(Integer year,Integer month,Integer day) -&gt; Date</tt><br>
      Construct <i>Date.</i><br>
      <br>
      <tt>time(Timeval) -&gt; Time</tt><br>
      Extract <i>Time </i>from <i>Timeval.</i><br>
      <br>
      <tt>date(Timeval) -&gt; Date</tt><br>
      Extract <i>Date </i>from <i>Timeval.</i><br>
      <br>
      <tt>date_time_to_timeval(Date, Time) -&gt; Timeval</tt><br>
      Combine <i>Date </i>and <i>Time </i>to <i>Timeval.</i><br>
      <br>
      <tt>year(Timeval) -&gt; Integer</tt><br>
      Extract year from <i>Timeval.</i><br>
      <br>
      <tt>month(Timeval) -&gt; Integer</tt><br>
      Extract month from <i>Timeval.</i><br>
      <br>
      <tt>day(Timeval) -&gt; Integer</tt><br>
      Extract day from <i>Timeval.</i><br>
      <br>
      <tt>hour(Timeval) -&gt; Integer</tt><br>
      Extract hour from <i>Timeval.</i><br>
      <br>
      <tt>minute(Timeval) -&gt; Integer</tt><br>
      Extract minute from <i>Timeval.</i><br>
      <br>
      <tt>second(Timeval) -&gt; Integer</tt><br>
      Extract second from <i>Timeval.</i><br>
      <br>
      <tt>year(Date) -&gt; Integer</tt><br>
      Extract year from <i>Date.</i><br>
      <br>
      <tt>month(Date) -&gt; Integer</tt><br>
      Extract month from <i>Date.</i><br>
      <br>
      <tt>day(Date) -&gt; Integer</tt><br>
      Extract day from <i>Date.</i><br>
      <br>
      <tt>hour(Time) -&gt; Integer</tt><br>
      Extract hour from <i>Time.</i><br>
      <br>
      <tt>minute(Time) -&gt; Integer</tt><br>
      Extract minute from <i>Time.</i><br>
      <br>
      <tt>second(Time) -&gt; Integer</tt><br>
      Extract second from <i>Time.</i><br>
      <br>
      <tt>timespan(Timeval, Timeval) -&gt; (Time, Integer usec)<br>
      </tt>Compute difference in <i>Time </i>and microseconds between
      two time values<br>
      <br>
      <br>
      <a name="SORT"></a>
      <h2> 8.6 Sorting functions</h2>
      There are several functions that can be used to sort bags or
      vectors.<br>
      <h3>Sorting by tuple order</h3>
      A natural sort order is often to sort the result tuples of a bag
      returned from a query or a function based on the sort order of all
      elements in the result tuples. <br>
      <br>
      Function signatures:<br>
      <pre>sort(Bag b)-&gt;Vector<br>sort(Bag b, Charstring order)-&gt;Vector<br></pre>
      <span style="font-weight: bold;">Notice</span> that the result of
      sorting an unordered bag is a <a href="#vector">vector</a>. <br>
      <br>
      For example:<br>
      <pre>Amos 1&gt; sort(1-<a href="#iota">iota</a>(1,3));<br>=&gt; {-2,-1,0}<br>Amos 2&gt; sort(1-iota(1,3),'dec');<br>{0,-1,-2}<br>Amos 3&gt; sort(select i, 1-i from Number i where i in <a href="#iota">iota</a>(1,3));<br>{{1,0},{2,-1},{3,-2}}<br></pre>
      The default first case is to sort the result in increasing order.
      <br>
      <br>
      In the second case a second argument specifies the <span
        style="font-style: italic;">ordering direction</span>, which can
      be <span style="font-style: italic;">'inc'</span> (increasing) or
      <span style="font-style: italic;">'dec'</span> (decreasing).&nbsp;
      <br>
      <br>
      The third case illustrates how the result tuples are ordered for
      queries returning bags of&nbsp; tuples. The result tuples are
      converted into <a href="#vector">vectors</a>.<br>
      <br>
      <span style="font-weight: bold;">Notice</span> that the sort order
      is not preserved if a sorted vector is converted to a bag as the
      query optimizer is free to return elements of bags in any order. <br>
      For example:<br>
    </span><span style="font-family: monospace;">&nbsp;&nbsp; select x
      from Number x where x in -<a href="#iota">iota</a>(1,5) and x in
      sort(-iota(3,5));</span><span style="font-family: Times New
      Roman;"><br>
      returns the unsorted bag<br>
    </span><span style="font-family: monospace;">&nbsp; -3</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; -4</span><br
      style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp; -5</span><span
      style="font-family: Times New Roman;"><br>
      even though<br>
    </span><span style="font-family: monospace;">sort(-iota(3,5)) -&gt;
      {-5,-4,-3}</span><span style="font-family: Times New Roman;"><br>
      &nbsp;<br>
      <span style="font-weight: bold;">Notice</span> that surrogate
      object will be sorted too based on their OID numbers, which
      usually has no meaning.<br>
      <h3>Sorting bags by ordering directives<br>
      </h3>
      A common case is sorting of result tuples from queries and
      functions ordered by <span style="font-style: italic;">ordering
        directives</span>. An ordering directive is a pair of a position
      number in a result tuple of a bag to be sorted and an ordering
      direction. <br>
      <br>
      Function signatures:
      <pre>sortbagby(Bag b, Integer pos, Charstring order) -&gt; Vector<br>sortbagby(Bag b, Vector of Integer pos, Vector of Charstring order)-&gt;Vector<br></pre>
      For example:<br>
      <pre>Amos 1&gt; sortbagby((select i, mod(i,2) from Number i where i in <a href="#iota">iota</a>(1,3)),1,'dec');<br>=&gt; {{3,1},{2,0},{1,1}}<br>Amos 2&gt; sortbagby((select i, mod(i,2) from Number i where i in iota(1,3)),{2,1},{'inc','inc'});<br>=&gt; {{2,0},{1,1},{3,1}}<br></pre>
      In the first case a single tuple ordering directive i specified by
      two arguments, one for the tuple position and one for the ordering
      direction. The result tuple positions are enumerated 1 and up.<br>
      <br>
      The second case illustrates how several tuples positions with
      different ordering directions can be specified.<span
        style="font-family: monospace;"><br>
      </span><b><br>
      </b>
      <h3>Sorting bags or vectors with a custom comparison function</h3>
      This group of sort functions are useful to sort bags or <a
        href="#vector">vectors</a> of either objects or tuples with a
      custom function supplied by the user. Either the function object
      or function named can be supplied. The comparison function must
      take two arguments with types compatible with the elements of the
      bag or the vector and return a boolean value. Signatures: <br>
      <pre>sortvector(Vector v1, Function compfno) -&gt; Vector<br>sortvector(Vector v, Charstring compfn) -&gt; Vector<br>sortbag(Bag b, Function compfno) -&gt; Vector <br>sortbag(Bag b, Charstring compfn) -&gt; Vector      </pre>
      <b>Example:</b> <br>
      <pre>create function younger(Person p1, Person p2) -&gt; Boolean <br>as age(p1) &lt; age(p2); <br><br>/* Sort all persons sorted by their age */<br>sortbag((select p from Person p), 'YOUNGER');</pre>
      <h2><a name="system-metadata"></a> 8.7 Accessing system meta-data</h2>
      The data that the system internally uses for maintaining the
      database is exposed to the query language as well and can be
      queried in terms of types and functions as other data. For
      example:<br>
      <ul>
        <li>The types and functions used in a database are accessible
          through system functions. It is possible to search the
          database for types and functions and how they relate. </li>
        <li>The goovi browser available from javaamos by calling the
          system function goovi(); presents the database graphically. It
          is written completely as an application Java program using
          AmosQL queries as the only interface to the Amos II kernel.</li>
      </ul>
      <h3><a name="type-metadata"></a>8.7.1 Type meta-data<br>
      </h3>
      <tt>alltypes() -&gt; Bag of Type</tt><br>
      returns all types in the database.
      <p><span style="font-family: monospace;"></span><tt>subtypes(Type
          t) -&gt; Bag of Type s<br>
          supertypes(Type t) -&gt; Bag of Type s</tt><br>
        returns the types immediately below/above type <tt>t</tt> in
        the type hierarchy. </p>
      <p><tt>allsupertypes(Type t) -&gt; Bag of Type s</tt><br>
        returns all types above <tt>t</tt> in the type hierarchy. </p>
      <p><tt>typesof(Object o) -&gt; Bag of Object t</tt><br>
        returns the type set of an object. </p>
      <p><tt>typeof(Object o) -&gt; Type t</tt><br>
        returns the most specific type of an object.<br>
      </p>
      <p> <tt>typenamed(Charstring nm) -&gt; Type t</tt><br>
        returns the type named <tt>nm</tt>. Notice that type names are
        in upper case. </p>
      <p> <tt>name(Type t) -&gt; Charstring nm</tt><br>
        returns the name of the type <tt>t</tt>.<br>
      </p>
      <p> <tt>attributes(Type t) -&gt; Bag of Function g</tt><br>
        returns the <a href="#overloaded-functions">generic</a>
        functions having a single argument of type <tt>t</tt> and a
        single result. </p>
      <p> <tt>methods(Type t) -&gt; Bag of Function r</tt><br>
        returns the resolvents having a single argument of type <tt>t</tt>
        and a single result.<br>
      </p>
      <p><tt>cardinality(Type t) -&gt; Integer c</tt><br>
        returns the number of object of type <tt>t</tt> and all its
        subtypes. </p>
      <p> </p>
      <p> <tt>objectname(Object o, Charstring nm) -&gt; Boolean</tt><br>
        returns <tt>TRUE</tt> if the object <tt>o</tt> has the name <tt>nm</tt>.<br>
      </p>
      <h3><a name="function-metadata"></a>8.7.2 Function meta-data<br>
      </h3>
      <p> </p>
      <p><tt>allfunctions() -&gt; Bag of Function<br>
        </tt>returns all functions in the database.<br>
        <span style="font-family: monospace;"></span><br
          style="font-family: monospace;">
        <span style="font-family: monospace;"></span><tt>functionnamed(Charstring




          nm) -&gt; Function</tt><br>
        returns the object representing the function named <tt>nm</tt>.
        Useful for <a href="#second-order-functions">second order
          functions</a>.<br>
      </p>
    </span><span style="font-family: Times New Roman;"></span><span
      style="font-family: Times New Roman;">
      <p><span style="font-family: monospace;">theresolvent(Charstring
          nm) -&gt; Function</span><br>
        returns the single <a href="#overloaded-functions">resolvent</a>
        of a generic function named <span style="font-style: italic;">nm</span>.
        If there is more than one resolvent for <span
          style="font-style: italic;">nm</span> an error is raised. If <span
          style="font-style: italic;">fn</span> is the name of a
        resolvent its functional is returned.&nbsp; The notation <a
          href="#functional-constant"><span style="font-style: italic;">#'...'</span>
        </a>is syntactic sugar for <span style="font-style: italic;">theresolvent('..')</span>;<br>
      </p>
      <p><tt>name(Function fn) -&gt; Charstring</tt><br>
        returns the name of the function <tt>fn</tt>.</p>
      <p> <span style="font-family: Times New Roman;"> </span></p>
      <p><span style="font-family: monospace;">signature(Function
          f)&nbsp; -&gt; Charstring</span><br>
        returns the signature of <span style="font-style: italic;">f.</span><br>
      </p>
    </span><span style="font-family: Times New Roman;"></span><tt>kindoffunction(Function
f)
-&gt;




      Charstring</tt><br>
    returns the kind of the function <tt>f</tt> as a string. The result
    can be one of 'stored', 'derived', 'foreign' or 'overloaded'.
    <p></p>
    <p> <tt>generic(Function f) -&gt; Function</tt><br>
      returns the <a href="#overloaded-functions">generic</a> function
      of a resolvent. </p>
    <p> <tt>resolvents(Function g) -&gt; Bag of Function</tt><br>
      returns the resolvents of an <a href="#overloaded-functions">overloaded</a>
      function <tt>g</tt>. </p>
    <p> <tt>resolventtype(Function fn) -&gt; Bag of Type</tt><br>
      returns the types of only the <span style="font-style: italic;">first</span>
      argument of the resolvents of function resolvent <tt>fn</tt>. </p>
    <p> <tt>arguments(Function r) -&gt; Bag of Vector<br>
      </tt>returns <a href="#vector">vector</a> describing arguments of
      signature of resolvent <tt>r</tt>. Each element in the vector is
      a triplet (vector) describing one of the arguments with structure
      <tt>{type,name,uniqueness} </tt>where <tt>type</tt> is the type
      of the argument, <tt>name</tt> is the identifier for the
      argument, and <tt>uniqueness</tt> is either<tt> "key" </tt>or <tt>"nonkey"</tt>
      depending on the declaration of the argument.. For example, <tt><br>
        arguments(resolvents(<a href="#functional-constant">#'timespan'</a>)))</tt><tt>&nbsp;




        <br>
        --&gt; {{#[OID 371 "TIMEVAL"],"TV1","nonkey"},{#[OID 371
        "TIMEVAL"],"TV2","nonkey"}}<br>
      </tt> </p>
    <p><tt>results(Function r) -&gt; Bag of Vector</tt><br>
      Analogous to arguments for result (tuple) of function.<br>
    </p>
    <p> <tt>arity(Function f)-&gt; Integer</tt><br>
      returns the number of arguments of function. </p>
    <p> <tt>width(Function f) -&gt; Integer</tt><br>
      returns the width of the result tuple of function <tt>f</tt>.<br>
    </p>
    <h2><a name="code-search"></a>8.8 Searching source code</h2>
    The source codes all functions except some basic system functions
    are stored in the database. You can retrieve the source code for a
    particular function, search for functions whose names contain some
    string, or make searches based on the source code itself. Some
    system functions are available to do this.<br>
    <br>
    <span style="font-family: monospace;">apropos(Charstring str) -&gt;
      Bag of Function</span><br>
    returns all functions in the system whose name contains the string <span
      style="font-style: italic;">str</span>. Only the <a
      href="#overloaded-functions">generic</a> name of the function is
    used in the search. The string is not case sensitive. For example:<br>
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
      apropos("plus");</span><br>
    returns all functions whose generic name contains 'PLUS'. <br>
    <p><span style="font-family: monospace;">sourcecode(Function f)
        -&gt; Bag of Charstring<br>
        sourcecode(Charstring fname) -&gt; Bag of Charstring<br>
      </span>returns the sourcecode of a function, if available. For <a
        href="#overloaded-functions">generic</a> functions the sources
      of all resolvents are returned. For example, to find all functions
      whose definitions contain the string 'tclose' use:<br>
      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;
        select sc <br>
        &nbsp;&nbsp;&nbsp;&nbsp; from Function f, Charstring sc <br>
        &nbsp;&nbsp;&nbsp;&nbsp; where like_i(sc,"*tclose*") and
        sourcecode(f)=sc;<br>
      </span></p>
    <p> <tt>usedwhere(Function f) -&gt; Function c</tt><br>
      returns the functions calling the function <tt>f</tt>. </p>
    <p> <tt>useswhich(Function f) -&gt; Function c</tt><br>
      returns the functions called from the function <tt>f</tt>.</p>
    <p><span style="font-family: monospace;">userfunctions() -&gt; Bag
        of Function</span><br style="font-family: monospace;">
      returns all user defined functions in the database.<br>
    </p>
    <p><span style="font-family: monospace;">usertypes() -&gt; Bag of
        Type</span><span style="font-family: monospace;"></span><br
        style="font-family: monospace;">
      returns all user defined types in the database.<br>
    </p>
    <p><tt>allfunctions(Type t)-&gt; Bag of Function</tt><br>
      returns all functions where one of the arguments are of type <span
        style="font-style: italic;">t</span>.<br>
    </p>
    <h2><a name="extents"></a>8.9 Extents </h2>
    <span style="font-family: Times New Roman;"> </span><span
      style="font-family: Times New Roman;">The local Amos II database
      can be regarded as a set of <i>extents</i>. There are two kinds
      of extents:
      <ul>
        <li> <i>Type extents</i> represent surrogate objects belonging
          to a particular type.
          <p> </p>
          <ul>
            <li>The <i>deep extent</i> of a type is defined as the set
              of all surrogate objects belonging to that type and to all
              its descendants in the type hierarchy. The deep extent of
              a type is retrieved with:
              <pre>extent(Type t)-&gt;Bag of Object</pre>
              For example, to count how many functions are defined in
              the database call:<br>
              <pre>   count(extent(typenamed("function")));</pre>
              To get all surrogate objects in the database call:<br>
              <span style="font-family: monospace;">&nbsp;&nbsp;
                extent(typenamed("object"))</span><br>
              <br>
              The function <span style="font-family: monospace;">allobjects();</span>
              does the same.<br>
            </li>
            <p> </p>
            <li> The <i>shallow extent</i> of a type is defined as all
              surrogate objects belonging only to that type but <span
                style="font-style: italic;">not</span> to any of its
              descendants. The shallow extent is retrieved with:
              <pre>shallow_extent(Type t)-&gt;Bag of Object</pre>
              For example:
              <pre>   shallow_extent(typenamed("object"));</pre>
              returns nothing since type <tt>Object</tt> has no own
              instances. </li>
          </ul>
          <p> </p>
        </li>
        <li> <a name="function-extent"></a> <i>Function extents</i>
          represent the state of stored functions. The extent of a
          function is the bag of tuples mapping its argument(s) to the
          corresponding result(s). The function <tt>extent</tt> returns
          the extent of the function <tt>fn</tt>. The extent tuples are
          returned as a bag of <a
            href="file:///C:/AmosNT/doc/amos_users_guide.html#vector">vectors</a>.
          The function can be any kind of function.<br>
          <br>
          <pre>extent(Function fn) -&gt; Bag of Vector</pre>
          For example,&nbsp;
          <pre>   extent(<a href="#functional-constant">#'coercers'</a>); <br></pre>
          For stored functions the extent is directly stored in the
          local database. The example query thus returns the state of
          all stored functions. The state of the local database is this
          state plus the deep extent of type <tt>Object</tt>.
          <p> The extent is always defined for stored functions and can
            also be computed for derived functions through their
            function definitions. The extent of a derived function may
            not be computable, <i>unsafe</i>, in which case the extent
            function returns nothing. </p>
          <p> The extent of a foreign function is always empty. </p>
          <p> The extent of a <a href="#overloaded-functions">generic</a>
            function is the union of the extents of its resolvents. </p>
        </li>
      </ul>
      <a name="62191"></a>
      <h2> 8.10 Query optimizer tuning</h2>
      <pre><br>optmethod(Charstring new) -&gt; Charstring old<font face="Times New Roman, Times, serif"><big><br>sets the optimization method used for cost-based optimization in Amos II to the method named new. <big><br></big>Three optimization modes for AmosQL queries can be chosen:</big></font><tt><br>"ranksort"</tt>: <big><font face="Times New Roman, Times, serif">(default) is fast but not always optimal.&nbsp;</font></big> <br><tt>"exhaustive"</tt>: <big><font face="Times New Roman, Times, serif">is optimal but it may slow down the optimizer considerably.</font></big><tt><br>"randomopt"</tt>: <big><font face="Times New Roman, Times, serif">is a combination of two random optimization heuristics:<br><i>Iterative improvement</i> and <i>sequence heuristics</i> <a href="#Nas93">[Nas93]</a>.</font></big>        <br></pre>
      <tt>optmethod </tt>returns the old setting of the optimization
      method.<br>
      <br>
      Random optimization can be tuned by using the function:&nbsp;
      <pre>optlevel(Integer i,Integer j);</pre>
      where i and j are integers specifying number of iterations in
      iterative improvement and sequence heuristics, respectively.
      Default settings is i=5 and j=5.&nbsp;
      <pre>reoptimize(Function f) -&gt; Boolean<br>reoptimize(Charstring f) -&gt; Boolean<br><big><font face="Times New Roman, Times, serif">reoptimizes function named fn. <br></font></big></pre>
      <p><a name="unloading"></a> </p>
      <h2>8.11 Unloading</h2>
      The data stored in the local database can be unloaded to a text
      file as an <i>unload script</i> of AmosQL statements generated by
      the system. The state of the database can be restored by loading
      the unload script as any other AmosQL file. Unloading is useful
      for backups and for transporting data between different systems
      such as different Amos II versions or Amos II systems running on
      different computers. The unload script can be edited in case the
      schema has changed.
      <p> <tt>unload(Charstring filename)-&gt;Boolean</tt><br>
        generates an AmosQL script that restores the current local
        database state if loaded into an Amos II peer with <b>the same
          schema</b> as the current one. </p>
      <p> <tt>excluded_fns()-&gt;Bag of Function</tt><br>
        set of functions that should <b>not</b> be unloaded. Can be
        updated by user.<br>
        <br>
        <a name="miscellaneous"></a><br>
      </p>
      <p><a name="62283"></a> </p>
      <h2> 8.12 Miscellaneous</h2>
    </span><span style="font-family: Times New Roman;"><tt>apply(Function
fn,




        Vector args) -&gt; Bag of Vector r</tt> <br>
      calls the AmosQL function <span style="font-family: monospace;">fn<span
          style="font-family: Times New Roman;"> </span></span></span><span
      style="font-family: Times New Roman;">with elements in vector </span><span
      style="font-family: Times New Roman;"><span style="font-family:
        monospace;">args</span></span><span style="font-family: Times
      New Roman;"> as arguments and returns the result tuples as
      vectors.<br>
      <br>
    </span><span style="font-family: Times New Roman;"><tt>evalv(Charstring
stmt)




        -&gt; Bag of Vector r</tt> <br>
      evaluates the AmosQL statement <tt>stmt </tt></span><span
      style="font-family: Times New Roman;">and returns the result
      tuples as vectors.</span><span style="font-family: Times New
      Roman;"></span><span style="font-family: Times New Roman;"><tt> </tt>
      <p> <tt><br>
          error(Charstring msg) -&gt; Boolean</tt><br>
        prints an error message on the terminal and raises an exception.
        Transaction aborted.<br>
      </p>
    </span><span style="font-family: Times New Roman;">
      <p><span style="font-family: monospace;">output_lines(Number n)
          -&gt; Number</span><br>
        controls how many lines to print on standard output before
        prompting for more lines. By default the system prints the <span
          style="font-family: Times New Roman;">entire result of a query
        </span>on standard output. The user can interrupt the printing
        by CTRL-C. However, when running under Emacs and Windows the
        CTRL-C method to terminate an output may not be effective. As an
        alternative to CTRL-C <span style="font-style: italic;">output_lines(n)</span>
        causes the system to prompt for more output lines after <span
          style="font-style: italic;">n</span> lines have been printed
        on standard output. <span style="font-style: italic;">output_lines(0)</span>
        turns off output line control.<br>
      </p>
      <p> </p>
      <tt>print(Object x) -&gt; Boolean<br>
      </tt> prints <tt>x</tt>. Always returns <tt>true</tt>. The
      printing is by default to the standard output (console) of the
      peer where <tt>print</tt> is executed but can be redirected to a
      file by the function <tt>openwritefile</tt>:
      <p> </p>
      <tt>openwritefile(Charstring filename)-&gt;Boolean</tt> <br>
      <tt>openwritefile</tt> changes the output stream for <tt>print</tt>
      to the specified filename. The file is closed and output directed
      to standard output by calling <tt>closewritefile();</tt>.<br>
      <tt><br>
        filedate(Charstring file) -&gt; Date</tt><br>
      returns the time for modification or creation of <span
        style="font-family: monospace;">file</span>.<br>
      <br>
      <tt>amos_version() -&gt; Charstring</tt><br>
      returns string identifying the current version of Amos II.
      <p> </p>
      <tt></tt>
      <p><tt>quit;</tt> <br>
        quits Amos II. </p>
      <p> </p>
      <tt>exit;</tt> <br>
      returns to the program that called Amos II if the system is
      embedded in some other system. <br>
      Same as <tt>quit;</tt> for stand-alone Amos II.
      <p></p>
      <pre><br>goovi();<font face="Times New Roman, Times, serif"><br><big>starts the multi-database browser GOOVI<a href="#CR01">[CR01]</a>. <br>This works only under JavaAmos.</big></font><big> </big>           <br></pre>
      <p>The <i>redirect</i> statement reads AmosQL statements from a
        file:&nbsp; </p>
      <pre>redirect-stmt ::= '&lt;' <a href="#string-constant">string-constant</a></pre>
      For example&nbsp;
      <pre>&lt; 'person.amosql';<br><br></pre>
      <span style="font-family: monospace;">load_AmosQL(Charstring
        filename)-&gt;Charstring</span><br>
      loads a file containing AmosQL statements.<br>
      <br>
      <span style="font-family: monospace;">loadSystem(Charstring dir,
        Charstring filename)-&gt;Charstring</span><br>
      loads a master file, <span style="font-family: monospace;">filename,</span>
      containing an AmosQL script defining a subsystem. The current
      directory is temporarily set to <span style="font-family:
        monospace;">dir</span> while loading.<br>
      The file is not loaded if it was previously loaded into the
      database. To see what master files are currently loaded, call <br>
      <span style="font-family: monospace;">loadedSystems()</span><br>
      <br>
      <span style="font-family: monospace;">getenv(Charstring
        var)-&gt;Charstring value</span><br>
      retrieves the value of OS environment variable <span
        style="font-family: monospace;">var</span>. Generates an error
      of variable not set.<br>
      <br>
      The <tt>trace </tt>and <tt>untrace </tt>functions are used for
      tracing foreign function calls:<br>
      <br>
      &nbsp;&nbsp;&nbsp; <tt>trace(Function fno)-&gt;Bag of Function r<br>
        &nbsp; trace(Charstring fn)-&gt;Bag of Function r<br>
        &nbsp; untrace(Function fno)-&gt;Bag of Function r<br>
        &nbsp; untrace(Charstring fn)-&gt;Bag of Function r</tt><br>
      <br>
      If an <a href="#overloaded-functions">overloaded</a> functions is
      (un)traced it means that all its resolvents are (un)traced.
      Results are the foreign functions (un)traced. For example:<br>
      <br>
      <tt>Amos 2&gt; trace("iota");<br>
        #[OID 116 "INTEGER.INTEGER.IOTA-&gt;INTEGER"]<br>
        Amos 2&gt; <a href="#iota">iota</a>(1,3);<br>
        &gt;&gt;#[OID 116 "INTEGER.INTEGER.IOTA-&gt;INTEGER"]#(1 3 *)<br>
        &lt;&lt;#[OID 116 "INTEGER.INTEGER.IOTA-&gt;INTEGER"]#(1 3 1)<br>
        1<br>
        &lt;&lt;#[OID 116 "INTEGER.INTEGER.IOTA-&gt;INTEGER"]#(1 3 2)<br>
        2<br>
        &lt;&lt;#[OID 116 "INTEGER.INTEGER.IOTA-&gt;INTEGER"]#(1 3 3)<br>
        3<br>
        Amos 2&gt;<br>
        <br>
      </tt><tt>dp(Object x, Number priority)-&gt; Boolean</tt> <br>
      For debug printing in where clauses. Prints<tt> x</tt> on the
      console. Always returns <tt>true</tt>. The placement of <tt>dp</tt>
      in the execution plan is regulated with <tt>priority</tt> which
      must be positive numeric constant. The higher priority the earlier
      in the execution plan. <tt><br>
      </tt><br>
      <a name="62618"></a>
      <h1>9 References</h1>
      <p><a name="CR01"></a>[CR01]K.Cassel and T.Risch: <a
          href="http://www.it.uu.se/research/group/udbl/publ/goovipaper3.pdf">An




          Object-Oriented Multi-Mediator Browser</a>. Presented at <span
          style="font-style: italic;">2nd International Workshop on User
          Interfaces to Data Intensive Systems</span><a
          href="http://www.uidis01.ethz.ch/"><i></i></a>, Z&uuml;rich,
        Switzerland, May 31 - June 1, 2001</p>
      <p><a name="ER00"></a>[ER00] D.Elin and T. Risch: <a
          href="http://user.it.uu.se/%7Etorer/publ/javaapi.pdf">Amos II
          Java Interfaces</a>,&nbsp; Uppsala University, 2000.</p>
      <a name="FR95"></a>[FR95] S. Flodin and T. Risch, <a
        href="http://user.it.uu.se/%7Etorer/publ/vldb95.pdf">Processing
        Object-Oriented Queries with Invertible Late Bound Functions</a>,
      <i>Proc. VLDB Conf.</i>, Z&uuml;rich, Switzerland, 1995.<br>
      <br>
      <a name="FR97"></a>[FR97] G. Fahl and T. Risch: <a
        href="http://www.it.uu.se/research/group/udbl/publ/vldbj97.pdf">Query




        Processing over Object Views of Relational Data</a>, The VLDB
      Journal , Vol. 6 No. 4, November 1997, pp 261-281. <br>
      <br>
      <p><a name="JR99a"></a>[JR99a] V.Josifovski, T.Risch: <b>Functional
Query




          Optimization over Object-Oriented Views for Data Integration </b>
        <i>Journal of Intelligent Information Systems (JIIS)</i>, Vol.
        12, No. 2-3, 1999. </p>
      <p><a name="JR99b"></a>[JR99b] V.Josifovski, T.Risch: <a
          href="http://www.it.uu.se/research/group/udbl/publ/vldb99.pdf">Integrating
Heterogeneous




          Overlapping Databases through Object-Oriented Transformations</a>.
        In <i>Proc. 25th Intl. Conf. On Very Large Databases</i>,
        Edinburgh, Scotland, September 1999.<br>
      </p>
      <p><a name="JR02"></a>[JR02] V.Josifovski, T.Risch: <b>Query
          Decomposition for a Distributed Object-Oriented Mediator
          System </b>. <a
          href="http://www.wkap.nl/journalhome.htm/0926-8782"><i>Distributed




            and Parallel Databases J.</i></a>, Kluwer, May 2002.<br>
      </p>
      <p><a name="KJR03"></a>[KJR03] T.Katchaounov, V.Josifovski, and
        T.Risch: <a href="http://user.it.uu.se/%7Etorer/publ/dsve.pdf"><b>Scalable




            View Expansion in a Peer Mediator System</b></a>, <i>Proc.
          8th International Conference on Database Systems for Advanced
          Applications (DASFAA 2003)</i>, Kyoto, Japan, March 2003. </p>
      <p><a name="LR92"></a>[LR92] W.Litwin and T.Risch: Main Memory
        Oriented Optimization of OO Queries Using Typed Datalog with
        Foreign Predicates, <i>IEEE Transactions on Knowledge and Data
          Engineering</i>, Vol. 4, No. 6, December 1992 (<a
          href="http://www.it.uu.se/research/group/udbl/publ/tkde92.pdf">
          http://user.it.uu.se/~udbl/publ/tkde92.pdf</a>).&nbsp; </p>
      <p><a name="Nas93"></a>[Nas93] J.N&auml;s: <a
          href="http://www.it.uu.se/research/group/udbl/Theses/JoakimNasMSc.pdf">Randomized
optimization




          of object oriented queries in a main memory database
          management system</a>, MSc thesis, LiTH-IDA-Ex 9325
        Link&ouml;ping University 1993. </p>
      <p><a name="Ris00a"></a>[Ris00a] T.Risch: <a
          href="http://user.it.uu.se/%7Etorer/publ/external.pdf"> Amos
          II External Interfaces</a>, Uppsala University, 2000.<br>
      </p>
      <p><a name="Ris00b"></a>[Ris00b]T.Risch: <a
          href="http://user.it.uu.se/%7Etorer/publ/alisp2.pdf">ALisp v2
          User's Guide</a>, Uppsala University, 2006.<br>
      </p>
      <p><a name="RJK03"></a>[RJK03] T.Risch, V.Josifovski, and
        T.Katchaounov: <a
          href="http://user.it.uu.se/%7Etorer/publ/FuncMedPaper.pdf"><b>Functional




            Data Integration in a Distributed Mediator System</b></a>,
        in P.Gray, L.Kerschberg, P.King, and A.Poulovassilis (eds.): <span
          style="font-style: italic;">Functional Approach to Data
          Management - Modeling, Analyzing and Integrating Heterogeneous
          Data</span>, Springer, ISBN 3-540-00375-4, 2003.<!-- #EndEditable


















--></p>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
    </span>
  </body>
</html>
